
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>boot: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/guidomantilla/go-feather-lib/pkg/boot/builder.go (0.0%)</option>
				
				<option value="file1">github.com/guidomantilla/go-feather-lib/pkg/boot/functions.go (0.0%)</option>
				
				<option value="file2">github.com/guidomantilla/go-feather-lib/pkg/boot/types.go (0.0%)</option>
				
				<option value="file3">github.com/guidomantilla/go-feather-lib/pkg/common/assert/functions.go (0.0%)</option>
				
				<option value="file4">github.com/guidomantilla/go-feather-lib/pkg/common/config/functions.go (0.0%)</option>
				
				<option value="file5">github.com/guidomantilla/go-feather-lib/pkg/common/config/lookup_environment.go (0.0%)</option>
				
				<option value="file6">github.com/guidomantilla/go-feather-lib/pkg/common/environment/environment.go (0.0%)</option>
				
				<option value="file7">github.com/guidomantilla/go-feather-lib/pkg/common/environment/environment_options.go (0.0%)</option>
				
				<option value="file8">github.com/guidomantilla/go-feather-lib/pkg/common/environment/environment_options_chain.go (0.0%)</option>
				
				<option value="file9">github.com/guidomantilla/go-feather-lib/pkg/common/environment/functions.go (0.0%)</option>
				
				<option value="file10">github.com/guidomantilla/go-feather-lib/pkg/common/environment/types.go (0.0%)</option>
				
				<option value="file11">github.com/guidomantilla/go-feather-lib/pkg/common/errors/functions.go (0.0%)</option>
				
				<option value="file12">github.com/guidomantilla/go-feather-lib/pkg/common/log/functions.go (0.0%)</option>
				
				<option value="file13">github.com/guidomantilla/go-feather-lib/pkg/common/log/slog_handler_fanout.go (0.0%)</option>
				
				<option value="file14">github.com/guidomantilla/go-feather-lib/pkg/common/log/slog_logger.go (0.0%)</option>
				
				<option value="file15">github.com/guidomantilla/go-feather-lib/pkg/common/mocks/functions.go (0.0%)</option>
				
				<option value="file16">github.com/guidomantilla/go-feather-lib/pkg/common/properties/functions.go (0.0%)</option>
				
				<option value="file17">github.com/guidomantilla/go-feather-lib/pkg/common/properties/properties.go (0.0%)</option>
				
				<option value="file18">github.com/guidomantilla/go-feather-lib/pkg/common/properties/properties_source.go (0.0%)</option>
				
				<option value="file19">github.com/guidomantilla/go-feather-lib/pkg/common/rest/exceptions.go (0.0%)</option>
				
				<option value="file20">github.com/guidomantilla/go-feather-lib/pkg/common/server/functions.go (0.0%)</option>
				
				<option value="file21">github.com/guidomantilla/go-feather-lib/pkg/common/ssl/functions.go (0.0%)</option>
				
				<option value="file22">github.com/guidomantilla/go-feather-lib/pkg/common/utils/functions.go (0.0%)</option>
				
				<option value="file23">github.com/guidomantilla/go-feather-lib/pkg/common/validation/errors.go (0.0%)</option>
				
				<option value="file24">github.com/guidomantilla/go-feather-lib/pkg/common/validation/rules.go (0.0%)</option>
				
				<option value="file25">github.com/guidomantilla/go-feather-lib/pkg/datasource/connection.go (0.0%)</option>
				
				<option value="file26">github.com/guidomantilla/go-feather-lib/pkg/datasource/context.go (0.0%)</option>
				
				<option value="file27">github.com/guidomantilla/go-feather-lib/pkg/datasource/errors.go (0.0%)</option>
				
				<option value="file28">github.com/guidomantilla/go-feather-lib/pkg/datasource/transaction_handler.go (0.0%)</option>
				
				<option value="file29">github.com/guidomantilla/go-feather-lib/pkg/integration/channel_types.go (0.0%)</option>
				
				<option value="file30">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/channel_messages.go (0.0%)</option>
				
				<option value="file31">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/channel_receivers.go (0.0%)</option>
				
				<option value="file32">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/channel_senders.go (0.0%)</option>
				
				<option value="file33">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/errors.go (0.0%)</option>
				
				<option value="file34">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/headers.go (0.0%)</option>
				
				<option value="file35">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/headers_options.go (0.0%)</option>
				
				<option value="file36">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/headers_options_chain.go (0.0%)</option>
				
				<option value="file37">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/headers_validator.go (0.0%)</option>
				
				<option value="file38">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/message.go (0.0%)</option>
				
				<option value="file39">github.com/guidomantilla/go-feather-lib/pkg/integration/messaging/types.go (0.0%)</option>
				
				<option value="file40">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/connection.go (0.0%)</option>
				
				<option value="file41">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/connection_dialers.go (0.0%)</option>
				
				<option value="file42">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_amqp.go (0.0%)</option>
				
				<option value="file43">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_amqp_options.go (0.0%)</option>
				
				<option value="file44">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_amqp_options_chain.go (0.0%)</option>
				
				<option value="file45">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_streams.go (0.0%)</option>
				
				<option value="file46">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_streams_options.go (0.0%)</option>
				
				<option value="file47">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/consumer_streams_options_chain.go (0.0%)</option>
				
				<option value="file48">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/context.go (0.0%)</option>
				
				<option value="file49">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/context_options.go (0.0%)</option>
				
				<option value="file50">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/context_options_chain.go (0.0%)</option>
				
				<option value="file51">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/listener_amqp.go (0.0%)</option>
				
				<option value="file52">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/listener_streams.go (0.0%)</option>
				
				<option value="file53">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_amqp.go (0.0%)</option>
				
				<option value="file54">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_amqp_options.go (0.0%)</option>
				
				<option value="file55">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_amqp_options_chain.go (0.0%)</option>
				
				<option value="file56">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_streams.go (0.0%)</option>
				
				<option value="file57">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_streams_options.go (0.0%)</option>
				
				<option value="file58">github.com/guidomantilla/go-feather-lib/pkg/messaging/rabbitmq/producer_streams_options_chain.go (0.0%)</option>
				
				<option value="file59">github.com/guidomantilla/go-feather-lib/pkg/security/authentication_endpoint.go (0.0%)</option>
				
				<option value="file60">github.com/guidomantilla/go-feather-lib/pkg/security/authentication_service.go (0.0%)</option>
				
				<option value="file61">github.com/guidomantilla/go-feather-lib/pkg/security/authorization_filter.go (0.0%)</option>
				
				<option value="file62">github.com/guidomantilla/go-feather-lib/pkg/security/authorization_service.go (0.0%)</option>
				
				<option value="file63">github.com/guidomantilla/go-feather-lib/pkg/security/errors.go (0.0%)</option>
				
				<option value="file64">github.com/guidomantilla/go-feather-lib/pkg/security/functions.go (0.0%)</option>
				
				<option value="file65">github.com/guidomantilla/go-feather-lib/pkg/security/password_encoder_argon2.go (0.0%)</option>
				
				<option value="file66">github.com/guidomantilla/go-feather-lib/pkg/security/password_encoder_bcrypt.go (0.0%)</option>
				
				<option value="file67">github.com/guidomantilla/go-feather-lib/pkg/security/password_encoder_delegating.go (0.0%)</option>
				
				<option value="file68">github.com/guidomantilla/go-feather-lib/pkg/security/password_encoder_pbkdf2.go (0.0%)</option>
				
				<option value="file69">github.com/guidomantilla/go-feather-lib/pkg/security/password_encoder_scrypt.go (0.0%)</option>
				
				<option value="file70">github.com/guidomantilla/go-feather-lib/pkg/security/password_functions.go (0.0%)</option>
				
				<option value="file71">github.com/guidomantilla/go-feather-lib/pkg/security/password_generator.go (0.0%)</option>
				
				<option value="file72">github.com/guidomantilla/go-feather-lib/pkg/security/password_generator_options.go (0.0%)</option>
				
				<option value="file73">github.com/guidomantilla/go-feather-lib/pkg/security/password_generator_options_chain.go (0.0%)</option>
				
				<option value="file74">github.com/guidomantilla/go-feather-lib/pkg/security/password_manager.go (0.0%)</option>
				
				<option value="file75">github.com/guidomantilla/go-feather-lib/pkg/security/principal_manager_base.go (0.0%)</option>
				
				<option value="file76">github.com/guidomantilla/go-feather-lib/pkg/security/principal_manager_gorm.go (0.0%)</option>
				
				<option value="file77">github.com/guidomantilla/go-feather-lib/pkg/security/token_manager_jwt.go (0.0%)</option>
				
				<option value="file78">github.com/guidomantilla/go-feather-lib/pkg/security/token_manager_jwt_options.go (0.0%)</option>
				
				<option value="file79">github.com/guidomantilla/go-feather-lib/pkg/security/token_manager_jwt_options_chain.go (0.0%)</option>
				
				<option value="file80">github.com/guidomantilla/go-feather-lib/pkg/server/functions.go (0.0%)</option>
				
				<option value="file81">github.com/guidomantilla/go-feather-lib/pkg/server/server_base.go (0.0%)</option>
				
				<option value="file82">github.com/guidomantilla/go-feather-lib/pkg/server/server_cron.go (0.0%)</option>
				
				<option value="file83">github.com/guidomantilla/go-feather-lib/pkg/server/server_grpc.go (0.0%)</option>
				
				<option value="file84">github.com/guidomantilla/go-feather-lib/pkg/server/server_http.go (0.0%)</option>
				
				<option value="file85">github.com/guidomantilla/go-feather-lib/pkg/server/server_rabbitmq.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package boot

import (
        "context"
        "net/http"

        "github.com/gin-gonic/gin"
        slogGorm "github.com/orandin/slog-gorm"
        sloggin "github.com/samber/slog-gin"
        "google.golang.org/grpc"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/common/environment"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/common/rest"
        "github.com/guidomantilla/go-feather-lib/pkg/datasource"
        "github.com/guidomantilla/go-feather-lib/pkg/security"
)

type EnvironmentBuilderFunc func(appCtx *ApplicationContext) environment.Environment

type ConfigLoaderFunc func(appCtx *ApplicationContext)

type DatasourceContextBuilderFunc func(appCtx *ApplicationContext) datasource.Context

type DatasourceConnectionBuilderFunc func(appCtx *ApplicationContext) datasource.Connection[*gorm.DB]

type DatasourceTransactionHandlerBuilderFunc func(appCtx *ApplicationContext) datasource.TransactionHandler[*gorm.DB]

type PasswordGeneratorBuilderFunc func(appCtx *ApplicationContext) security.PasswordGenerator

type PasswordEncoderBuilderFunc func(appCtx *ApplicationContext) security.PasswordEncoder

type PasswordManagerBuilderFunc func(appCtx *ApplicationContext) security.PasswordManager

type PrincipalManagerBuilderFunc func(appCtx *ApplicationContext) security.PrincipalManager

type TokenManagerBuilderFunc func(appCtx *ApplicationContext) security.TokenManager

type AuthenticationServiceBuilderFunc func(appCtx *ApplicationContext) security.AuthenticationService

type AuthorizationServiceBuilderFunc func(appCtx *ApplicationContext) security.AuthorizationService

type AuthenticationEndpointBuilderFunc func(appCtx *ApplicationContext) security.AuthenticationEndpoint

type AuthorizationFilterBuilderFunc func(appCtx *ApplicationContext) security.AuthorizationFilter

type HttpServerBuilderFunc func(appCtx *ApplicationContext) (*gin.Engine, *gin.RouterGroup)

type GrpcServerBuilderFunc func(appCtx *ApplicationContext) (*grpc.ServiceDesc, any)

type BeanBuilder struct {
        Environment                  EnvironmentBuilderFunc
        Config                       ConfigLoaderFunc
        DatasourceContext            DatasourceContextBuilderFunc
        DatasourceConnection         DatasourceConnectionBuilderFunc
        DatasourceTransactionHandler DatasourceTransactionHandlerBuilderFunc
        PasswordEncoder              PasswordEncoderBuilderFunc
        PasswordGenerator            PasswordGeneratorBuilderFunc
        PasswordManager              PasswordManagerBuilderFunc
        PrincipalManager             PrincipalManagerBuilderFunc
        TokenManager                 TokenManagerBuilderFunc
        AuthenticationService        AuthenticationServiceBuilderFunc
        AuthorizationService         AuthorizationServiceBuilderFunc
        AuthenticationEndpoint       AuthenticationEndpointBuilderFunc
        AuthorizationFilter          AuthorizationFilterBuilderFunc
        HttpServer                   HttpServerBuilderFunc
        GrpcServer                   GrpcServerBuilderFunc
}

func NewBeanBuilder(ctx context.Context) *BeanBuilder <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up builder: context is nil")
        }</span>

        <span class="cov0" title="0">return &amp;BeanBuilder{

                Environment: func(appCtx *ApplicationContext) environment.Environment </span><span class="cov0" title="0">{
                        return environment.New(environment.OptionsChainBuilder().WithSSL().WithCmd(appCtx.CmdArgs).Build())
                }</span>,
                Config: func(appCtx *ApplicationContext) <span class="cov0" title="0">{
                        log.Warn("starting up - warning setting up configuration: config function not implemented")
                }</span>,
                DatasourceContext: func(appCtx *ApplicationContext) datasource.Context <span class="cov0" title="0">{
                        if !appCtx.Enablers.DatabaseEnabled </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if appCtx.DatabaseConfig != nil </span><span class="cov0" title="0">{
                                return datasource.NewContext(*appCtx.DatabaseConfig.DatasourceUrl, *appCtx.DatabaseConfig.DatasourceUsername, *appCtx.DatabaseConfig.DatasourcePassword, *appCtx.DatabaseConfig.DatasourceServer, *appCtx.DatabaseConfig.DatasourceService)
                        }</span>

                        <span class="cov0" title="0">log.Fatal("starting up - error setting up configuration: database config is nil")
                        return nil</span>
                },
                DatasourceConnection: func(appCtx *ApplicationContext) datasource.Connection[*gorm.DB] <span class="cov0" title="0">{
                        if !appCtx.Enablers.DatabaseEnabled </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if appCtx.DatabaseConfig != nil </span><span class="cov0" title="0">{
                                config := &amp;gorm.Config{
                                        SkipDefaultTransaction: true,
                                        Logger:                 slogGorm.New(slogGorm.WithHandler(log.AsSlogLogger().Handler()), slogGorm.WithTraceAll(), slogGorm.WithRecordNotFoundError()),
                                }
                                //TODO: create a factory function for enabling different database types not only: mysql.Open
                                return datasource.NewConnection(appCtx.DatasourceContext, mysql.Open(appCtx.DatasourceContext.Url()), config)
                        }</span>

                        <span class="cov0" title="0">log.Fatal("starting up - error setting up configuration: database config is nil")
                        return nil</span>
                },
                DatasourceTransactionHandler: func(appCtx *ApplicationContext) datasource.TransactionHandler[*gorm.DB] <span class="cov0" title="0">{
                        if !appCtx.Enablers.DatabaseEnabled </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if appCtx.DatabaseConfig != nil </span><span class="cov0" title="0">{
                                return datasource.NewOrmTransactionHandler(appCtx.DatasourceConnection)
                        }</span>

                        <span class="cov0" title="0">log.Fatal("starting up - error setting up configuration: database config is nil")
                        return nil</span>
                },
                PasswordEncoder: func(appCtx *ApplicationContext) security.PasswordEncoder <span class="cov0" title="0">{
                        return security.NewBcryptPasswordEncoder()
                }</span>,
                PasswordGenerator: func(appCtx *ApplicationContext) security.PasswordGenerator <span class="cov0" title="0">{
                        return security.NewPasswordGenerator()
                }</span>,
                PasswordManager: func(appCtx *ApplicationContext) security.PasswordManager <span class="cov0" title="0">{
                        return security.NewPasswordManager(appCtx.PasswordEncoder, appCtx.PasswordGenerator)
                }</span>,
                PrincipalManager: func(appCtx *ApplicationContext) security.PrincipalManager <span class="cov0" title="0">{
                        if !appCtx.Enablers.DatabaseEnabled </span><span class="cov0" title="0">{
                                return security.NewBasePrincipalManager(appCtx.PasswordManager)
                        }</span>

                        <span class="cov0" title="0">if appCtx.DatabaseConfig != nil </span><span class="cov0" title="0">{
                                return security.NewGormPrincipalManager(appCtx.DatasourceTransactionHandler, appCtx.PasswordManager)
                        }</span>

                        <span class="cov0" title="0">log.Fatal("starting up - error setting up configuration: database config is nil")
                        return nil</span>
                },
                TokenManager: func(appCtx *ApplicationContext) security.TokenManager <span class="cov0" title="0">{
                        options := security.JwtTokenManagerOptionsChainBuilder().WithIssuer(appCtx.AppName).
                                WithSigningKey([]byte(*appCtx.SecurityConfig.TokenSignatureKey)).
                                WithVerifyingKey([]byte(*appCtx.SecurityConfig.TokenVerificationKey)).Build()
                        return security.NewJwtTokenManager(options)
                }</span>,
                AuthenticationService: func(appCtx *ApplicationContext) security.AuthenticationService <span class="cov0" title="0">{
                        return security.NewDefaultAuthenticationService(appCtx.PasswordManager, appCtx.PrincipalManager, appCtx.TokenManager)
                }</span>,
                AuthorizationService: func(appCtx *ApplicationContext) security.AuthorizationService <span class="cov0" title="0">{
                        return security.NewDefaultAuthorizationService(appCtx.TokenManager, appCtx.PrincipalManager)
                }</span>,
                AuthenticationEndpoint: func(appCtx *ApplicationContext) security.AuthenticationEndpoint <span class="cov0" title="0">{
                        return security.NewDefaultAuthenticationEndpoint(appCtx.AuthenticationService)
                }</span>,
                AuthorizationFilter: func(appCtx *ApplicationContext) security.AuthorizationFilter <span class="cov0" title="0">{
                        return security.NewDefaultAuthorizationFilter(appCtx.AuthorizationService)
                }</span>,
                HttpServer: func(appCtx *ApplicationContext) (*gin.Engine, *gin.RouterGroup) <span class="cov0" title="0">{
                        if !appCtx.Enablers.HttpServerEnabled </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">recoveryFilter := gin.Recovery()
                        loggerFilter := sloggin.New(log.AsSlogLogger().WithGroup("http"))
                        customFilter := func(ctx *gin.Context) </span><span class="cov0" title="0">{
                                security.AddApplicationToContext(ctx, appCtx.AppName)
                                ctx.Next()
                        }</span>

                        <span class="cov0" title="0">engine := gin.New()
                        engine.Use(loggerFilter, recoveryFilter, customFilter)
                        engine.POST("/login", appCtx.AuthenticationEndpoint.Authenticate)
                        engine.GET("/health", func(ctx *gin.Context) </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusOK, gin.H{"status": "alive"})
                        }</span>)
                        <span class="cov0" title="0">engine.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusNotFound, rest.NotFoundException("resource not found"))
                        }</span>)
                        <span class="cov0" title="0">engine.GET("/info", func(ctx *gin.Context) </span><span class="cov0" title="0">{
                                ctx.JSON(http.StatusOK, gin.H{"appName": appCtx.AppName})
                        }</span>)

                        <span class="cov0" title="0">return engine, engine.Group("/api", appCtx.AuthorizationFilter.Authorize)</span>
                },
                GrpcServer: func(appCtx *ApplicationContext) (*grpc.ServiceDesc, any) <span class="cov0" title="0">{
                        if !appCtx.Enablers.GrpcServerEnabled </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">log.Fatal("starting up - error setting up grpc configuration: grpc server function not implemented")
                        return nil, nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package boot

import (
        "fmt"
        "net"
        "net/http"
        "strings"
        "syscall"

        "github.com/qmdx00/lifecycle"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        log "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/server"
)

type InitDelegateFunc func(ctx ApplicationContext) error

func Init(appName string, version string, args []string, enablers *Enablers, builder *BeanBuilder, fn InitDelegateFunc) error <span class="cov0" title="0">{

        log.Info(fmt.Sprintf("Application %s", strings.Join([]string{appName, version}, " - ")))

        if appName == "" </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the application: appName is empty")
        }</span>

        <span class="cov0" title="0">if args == nil </span><span class="cov0" title="0">{
                log.Warn("starting up - warning setting up the application: args is nil")
                args = make([]string, 0)
        }</span>

        <span class="cov0" title="0">if enablers == nil </span><span class="cov0" title="0">{
                log.Warn("starting up - warning setting up the application: http server, grpc server and database connectivity are disabled")
                enablers = &amp;Enablers{}
        }</span>

        <span class="cov0" title="0">if builder == nil </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the application: builder is nil")
        }</span>

        <span class="cov0" title="0">if fn == nil </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the application: fn is nil")
        }</span>

        <span class="cov0" title="0">app := lifecycle.NewApp(
                lifecycle.WithName(appName),
                lifecycle.WithVersion(version),
                lifecycle.WithSignal(syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGINT, syscall.SIGKILL),
        )

        ctx := NewApplicationContext(appName, version, args, enablers, builder)
        defer ctx.Stop()

        if err := fn(*ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal(fmt.Sprintf("starting up - error setting up the application: %s", err.Error()))
        }</span>

        <span class="cov0" title="0">if ctx.Enablers.HttpServerEnabled </span><span class="cov0" title="0">{
                if ctx.PublicRouter == nil || ctx.HttpConfig == nil || ctx.HttpConfig.Host == nil || ctx.HttpConfig.Port == nil </span><span class="cov0" title="0">{
                        log.Fatal("starting up - error setting up the application: http server is enabled but no public router or http config is provided")
                }</span>
                <span class="cov0" title="0">httpServer := &amp;http.Server{
                        Addr:              net.JoinHostPort(*ctx.HttpConfig.Host, *ctx.HttpConfig.Port),
                        Handler:           ctx.PublicRouter,
                        ReadHeaderTimeout: 60000,
                }
                app.Attach(server.BuildHttpServer(httpServer))</span>
        }

        <span class="cov0" title="0">if ctx.Enablers.GrpcServerEnabled </span><span class="cov0" title="0">{
                if ctx.GrpcServiceDesc == nil || ctx.GrpcServiceServer == nil || ctx.GrpcConfig == nil || ctx.GrpcConfig.Host == nil || ctx.GrpcConfig.Port == nil </span><span class="cov0" title="0">{
                        log.Fatal("starting up - error setting up the application: grpc server is enabled but no grpc service descriptor, grpc service server or grpc config is provided")
                }</span>
                <span class="cov0" title="0">srv := grpc.NewServer()
                srv.RegisterService(ctx.GrpcServiceDesc, ctx.GrpcServiceServer)
                reflection.Register(srv)
                app.Attach(server.BuildGrpcServer(net.JoinHostPort(*ctx.GrpcConfig.Host, *ctx.GrpcConfig.Port), srv))</span>
        }

        <span class="cov0" title="0">log.Info(fmt.Sprintf("Application %s started", strings.Join([]string{appName, version}, " - ")))
        return app.Run()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package boot

import (
        "database/sql"
        "fmt"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/xorcare/pointer"
        "google.golang.org/grpc"
        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/common/environment"
        log "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/datasource"
        "github.com/guidomantilla/go-feather-lib/pkg/security"
)

type Enablers struct {
        HttpServerEnabled bool
        GrpcServerEnabled bool
        DatabaseEnabled   bool
}

type HttpConfig struct {
        Host            *string
        Port            *string
        SwaggerPort     *string
        CorsAllowOrigin *string
}

type GrpcConfig struct {
        Host *string
        Port *string
}

type SecurityConfig struct {
        TokenSignatureKey       *string
        TokenVerificationKey    *string
        PasswordMinSpecialChars *string
        PasswordMinNumber       *string
        PasswordMinUpperCase    *string
        PasswordLength          *string
}

type DatabaseConfig struct {
        DatasourceUrl      *string
        DatasourceUsername *string
        DatasourcePassword *string
        DatasourceServer   *string
        DatasourceService  *string
}

type ApplicationContext struct {
        AppName                      string
        AppVersion                   string
        LogLevel                     string
        CmdArgs                      []string
        Enablers                     *Enablers
        HttpConfig                   *HttpConfig
        GrpcConfig                   *GrpcConfig
        SecurityConfig               *SecurityConfig
        DatabaseConfig               *DatabaseConfig
        Environment                  environment.Environment
        DatasourceContext            datasource.Context
        DatasourceConnection         datasource.Connection[*gorm.DB]
        DatasourceTransactionHandler datasource.TransactionHandler[*gorm.DB]
        PasswordEncoder              security.PasswordEncoder
        PasswordGenerator            security.PasswordGenerator
        PasswordManager              security.PasswordManager
        PrincipalManager             security.PrincipalManager
        TokenManager                 security.TokenManager
        AuthenticationService        security.AuthenticationService
        AuthenticationEndpoint       security.AuthenticationEndpoint
        AuthorizationService         security.AuthorizationService
        AuthorizationFilter          security.AuthorizationFilter
        PublicRouter                 *gin.Engine
        PrivateRouter                *gin.RouterGroup
        GrpcServiceDesc              *grpc.ServiceDesc
        GrpcServiceServer            any
}

func NewApplicationContext(appName string, version string, args []string, enablers *Enablers, builder *BeanBuilder) *ApplicationContext <span class="cov0" title="0">{

        if appName == "" </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the ApplicationContext: appName is empty")
        }</span>

        <span class="cov0" title="0">if version == "" </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the ApplicationContext: version is empty")
        }</span>

        <span class="cov0" title="0">if args == nil </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up the ApplicationContext: args is nil")
        }</span>

        <span class="cov0" title="0">if enablers == nil </span><span class="cov0" title="0">{
                log.Warn("starting up - warning setting up the application: http server, grpc server and database connectivity are disabled")
                enablers = &amp;Enablers{}
        }</span>

        <span class="cov0" title="0">if builder == nil </span><span class="cov0" title="0">{ //nolint:staticcheck
                log.Fatal("starting up - error setting up the ApplicationContext: builder is nil")
        }</span>

        <span class="cov0" title="0">ctx := &amp;ApplicationContext{
                AppName:    appName,
                AppVersion: version,
                CmdArgs:    args,
                Enablers:   enablers,
                SecurityConfig: &amp;SecurityConfig{
                        TokenSignatureKey:    pointer.Of("SecretYouShouldHide"),
                        TokenVerificationKey: pointer.Of("SecretYouShouldHide"),
                },
                HttpConfig: &amp;HttpConfig{
                        Host: pointer.Of("localhost"),
                        Port: pointer.Of("8080"),
                },
                GrpcConfig: &amp;GrpcConfig{
                        Host: pointer.Of("localhost"),
                        Port: pointer.Of("50051"),
                },
        }

        log.Debug("starting up - setting up environment variables")
        ctx.Environment = builder.Environment(ctx) //nolint:staticcheck

        log.Debug("starting up - setting up configuration")
        builder.Config(ctx) //nolint:staticcheck

        if ctx.Enablers.DatabaseEnabled </span><span class="cov0" title="0">{
                log.Debug("starting up - setting up db connectivity")
                ctx.DatasourceContext = builder.DatasourceContext(ctx)                       //nolint:staticcheck
                ctx.DatasourceConnection = builder.DatasourceConnection(ctx)                 //nolint:staticcheck
                ctx.DatasourceTransactionHandler = builder.DatasourceTransactionHandler(ctx) //nolint:staticcheck
        }</span> else<span class="cov0" title="0"> {
                log.Warn("starting up - warning setting up database configuration. database connectivity is disabled")
        }</span>

        <span class="cov0" title="0">log.Debug("starting up - setting up security")
        ctx.PasswordEncoder = builder.PasswordEncoder(ctx)                                                                          //nolint:staticcheck
        ctx.PasswordGenerator = builder.PasswordGenerator(ctx)                                                                      //nolint:staticcheck
        ctx.PasswordManager = builder.PasswordManager(ctx)                                                                          //nolint:staticcheck
        ctx.PrincipalManager, ctx.TokenManager = builder.PrincipalManager(ctx), builder.TokenManager(ctx)                           //nolint:staticcheck
        ctx.AuthenticationService, ctx.AuthorizationService = builder.AuthenticationService(ctx), builder.AuthorizationService(ctx) //nolint:staticcheck
        ctx.AuthenticationEndpoint, ctx.AuthorizationFilter = builder.AuthenticationEndpoint(ctx), builder.AuthorizationFilter(ctx) //nolint:staticcheck

        if ctx.Enablers.HttpServerEnabled </span><span class="cov0" title="0">{
                log.Debug("starting up - setting up http server")
                ctx.PublicRouter, ctx.PrivateRouter = builder.HttpServer(ctx) //nolint:staticcheck
        }</span> else<span class="cov0" title="0"> {
                log.Warn("starting up - warning setting up http configuration. http server is disabled")
        }</span>

        <span class="cov0" title="0">if ctx.Enablers.GrpcServerEnabled </span><span class="cov0" title="0">{
                log.Debug("starting up - setting up grpc server")
                ctx.GrpcServiceDesc, ctx.GrpcServiceServer = builder.GrpcServer(ctx) //nolint:staticcheck
        }</span> else<span class="cov0" title="0"> {
                log.Warn("starting up - warning setting up grpc configuration. grpc server is disabled")
        }</span>

        <span class="cov0" title="0">return ctx</span>
}

func (ctx *ApplicationContext) Stop() <span class="cov0" title="0">{

        var err error

        if ctx.DatasourceConnection != nil &amp;&amp; ctx.DatasourceContext != nil </span><span class="cov0" title="0">{

                var database *gorm.DB
                log.Debug("shutting down - closing up db connection")

                if database, err = ctx.DatasourceConnection.Connect(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("shutting down - error db connection: %s", err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">var db *sql.DB
                if db, err = database.DB(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("shutting down - error db connection: %s", err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">if err = db.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("shutting down - error closing db connection: %s", err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">log.Debug("shutting down - db connection closed")</span>
        }

        <span class="cov0" title="0">log.Info(fmt.Sprintf("Application %s stopped", strings.Join([]string{ctx.AppName, ctx.AppVersion}, " - ")))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package assert

import (
        "log"
        "reflect"

        "github.com/guidomantilla/go-feather-lib/pkg/common/utils"
)

func NotEmpty(object any, message string) <span class="cov0" title="0">{
        if utils.IsEmpty(object) </span><span class="cov0" title="0">{
                log.Fatal(message)
        }</span>
}

func NotNil(object any, message string) <span class="cov0" title="0">{
        if isNil(object) </span><span class="cov0" title="0">{
                log.Fatal(message)
        }</span>
}

func Equal(val1 any, val2 any, message string) <span class="cov0" title="0">{
        if !isEqual(val1, val2) </span><span class="cov0" title="0">{
                log.Fatal(message)
        }</span>
}

func NotEqual(val1 any, val2 any, message string) <span class="cov0" title="0">{
        if isEqual(val1, val2) </span><span class="cov0" title="0">{
                log.Fatal(message)
        }</span>
}

//

func nil(object any) bool <span class="cov0" title="0">{
        return isNil(object)
}</span>

//

func isNil(object any) bool <span class="cov0" title="0">{
        value := reflect.ValueOf(object)
        if !value.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">switch value.Kind() </span>{
        case
                reflect.Chan, reflect.Func,
                reflect.Interface, reflect.Map,
                reflect.Ptr, reflect.Slice, reflect.UnsafePointer:<span class="cov0" title="0">

                return value.IsNil()</span>
        }

        <span class="cov0" title="0">return false</span>
}

func isEqual(val1, val2 any) bool <span class="cov0" title="0">{
        v1 := reflect.ValueOf(val1)
        v2 := reflect.ValueOf(val2)

        if v1.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v1 = v1.Elem()
        }</span>

        <span class="cov0" title="0">if v2.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v2 = v2.Elem()
        }</span>

        <span class="cov0" title="0">if !v1.IsValid() &amp;&amp; !v2.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch v1.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                if v1.IsNil() </span><span class="cov0" title="0">{
                        v1 = reflect.ValueOf(nil)
                }</span>
        }

        <span class="cov0" title="0">switch v2.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                if v2.IsNil() </span><span class="cov0" title="0">{
                        v2 = reflect.ValueOf(nil)
                }</span>
        }

        <span class="cov0" title="0">v1Underlying := reflect.Zero(reflect.TypeOf(v1)).Interface()
        v2Underlying := reflect.Zero(reflect.TypeOf(v2)).Interface()

        if v1 == v1Underlying </span><span class="cov0" title="0">{
                if v2 == v2Underlying </span><span class="cov0" title="0">{
                        goto CASE4</span>
                } else<span class="cov0" title="0"> {
                        goto CASE3</span>
                }
        } else<span class="cov0" title="0"> {
                if v2 == v2Underlying </span><span class="cov0" title="0">{
                        goto CASE2</span>
                } else<span class="cov0" title="0"> {
                        goto CASE1</span>
                }
        }

CASE1:
        <span class="cov0" title="0">return reflect.DeepEqual(v1.Interface(), v2.Interface())
</span>CASE2:
        <span class="cov0" title="0">return reflect.DeepEqual(v1.Interface(), v2)
</span>CASE3:
        <span class="cov0" title="0">return reflect.DeepEqual(v1, v2.Interface())
</span>CASE4:
        <span class="cov0" title="0">return reflect.DeepEqual(v1, v2)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "context"

        envconfig "github.com/sethvargo/go-envconfig"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/environment"
)

func Process(ctx context.Context, environment environment.Environment, cfg *Config) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "processing config - error processing config: context is nil")
        assert.NotNil(environment, "processing config - error processing config: environment is nil")
        assert.NotNil(cfg, "processing config - error processing config: config is nil")

        return envconfig.ProcessWith(ctx, &amp;envconfig.Config{Target: cfg, Lookuper: &amp;EnvironmentLookup{environment: environment}})
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        envconfig "github.com/sethvargo/go-envconfig"

        "github.com/guidomantilla/go-feather-lib/pkg/common/environment"
)

var (
        _ envconfig.Lookuper = (*EnvironmentLookup)(nil)
        _ envconfig.Lookuper = (*MockLookuper)(nil)
)

type EnvironmentLookup struct {
        environment environment.Environment
}

func (lookuper *EnvironmentLookup) Lookup(key string) (string, bool) <span class="cov0" title="0">{
        value := lookuper.environment.Value(key).AsString()
        return value, value != ""
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package environment

import (
        properties "github.com/guidomantilla/go-feather-lib/pkg/common/properties"
)

const (
        SslPropertySourceName = "SSL_PROPERTY_SOURCE_NAME"
        OsPropertySourceName  = "OS_PROPERTY_SOURCE_NAME"
        CmdPropertySourceName = "CMD_PROPERTY_SOURCE_NAME" //nolint:gosec
)

const (
        SslServerName        = "SSL_SERVER_NAME"
        SslCaCertificate     = "SSL_CA_CERTIFICATE"
        SslClientCertificate = "SSL_CLIENT_CERTIFICATE"
        SslClientKey         = "SSL_CLIENT_KEY"
)

type environment struct {
        propertiesSources []properties.PropertiesSource
}

func New(options ...Options) Environment <span class="cov0" title="0">{
        environment := &amp;environment{
                propertiesSources: make([]properties.PropertiesSource, 0),
        }
        for _, opt := range options </span><span class="cov0" title="0">{
                opt(environment)
        }</span>

        <span class="cov0" title="0">return environment</span>
}

func (environment *environment) Value(property string) EnvVar <span class="cov0" title="0">{

        var value string
        for _, source := range environment.propertiesSources </span><span class="cov0" title="0">{
                internalValue := source.Get(property)
                if internalValue != "" </span><span class="cov0" title="0">{
                        value = internalValue
                        break</span>
                }
        }
        <span class="cov0" title="0">return NewEnvVar(value)</span>
}

func (environment *environment) ValueOrDefault(property string, defaultValue string) EnvVar <span class="cov0" title="0">{

        envVar := environment.Value(property)
        if envVar != "" </span><span class="cov0" title="0">{
                return envVar
        }</span>
        <span class="cov0" title="0">return NewEnvVar(defaultValue)</span>
}

func (environment *environment) PropertiesSources() []properties.PropertiesSource <span class="cov0" title="0">{
        return environment.propertiesSources
}</span>

func (environment *environment) AppendPropertiesSources(propertySources ...properties.PropertiesSource) <span class="cov0" title="0">{
        environment.propertiesSources = append(environment.propertiesSources, propertySources...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package environment

import (
        "os"
        "strings"

        "github.com/guidomantilla/go-feather-lib/pkg/common/properties"
)

var options_ = NewOptions()

func NewOptions() Options <span class="cov0" title="0">{
        return func(environment Environment) </span>{<span class="cov0" title="0">
        }</span>
}

type Options func(environment Environment)

func (options Options) WithCmd(cmdArgs []string) Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{
                if len(cmdArgs) != 0 </span><span class="cov0" title="0">{
                        cmdProperties := properties.New(properties.FromSlice(cmdArgs))
                        environment.AppendPropertiesSources(properties.NewSource(CmdPropertySourceName, cmdProperties))
                }</span>
        }
}

func (options Options) WithSSL() Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{

                ValueOrEmpty := func(key string) string </span><span class="cov0" title="0">{
                        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                                return value
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }

                <span class="cov0" title="0">BuildOrEmpty := func(key string) string </span><span class="cov0" title="0">{
                        if value := ValueOrEmpty(key); value != "" </span><span class="cov0" title="0">{
                                return strings.Join([]string{os.Getenv("PWD"), "ssl", value}, "/")
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                }

                <span class="cov0" title="0">sslProperties := properties.New()
                sslProperties.Add(SslServerName, ValueOrEmpty(SslServerName))
                sslProperties.Add(SslCaCertificate, BuildOrEmpty(SslCaCertificate))
                sslProperties.Add(SslClientCertificate, BuildOrEmpty(SslClientCertificate))
                sslProperties.Add(SslClientKey, BuildOrEmpty(SslClientKey))
                environment.AppendPropertiesSources(properties.NewSource(SslPropertySourceName, sslProperties))</span>
        }
}

func (options Options) WithOs() Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{
                osProperties := properties.New(properties.FromSlice(os.Environ()))
                environment.AppendPropertiesSources(properties.NewSource(OsPropertySourceName, osProperties))
        }</span>
}

func (options Options) WithArraySource(name string, array []string) Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{
                if strings.TrimSpace(name) != "" &amp;&amp; len(array) != 0 </span><span class="cov0" title="0">{
                        environment.AppendPropertiesSources(properties.NewSource(name, properties.New(properties.FromSlice(array))))

                }</span>
        }
}

func (options Options) WithPropertySources(propertySources ...properties.PropertiesSource) Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{
                if len(propertySources) != 0 </span><span class="cov0" title="0">{
                        environment.AppendPropertiesSources(propertySources...)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package environment

import "github.com/guidomantilla/go-feather-lib/pkg/common/properties"

type OptionsChain struct {
        chain []Options
}

func OptionsChainBuilder() *OptionsChain <span class="cov0" title="0">{
        return &amp;OptionsChain{
                chain: make([]Options, 0),
        }
}</span>

func (options *OptionsChain) Build() Options <span class="cov0" title="0">{
        return func(environment Environment) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(environment)
                }</span>
        }
}

func (options *OptionsChain) WithCmd(cmdArgs []string) *OptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, options_.WithCmd(cmdArgs))
        return options
}</span>

func (options *OptionsChain) WithSSL() *OptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, options_.WithSSL())
        return options
}</span>

func (options *OptionsChain) WithOs() *OptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, options_.WithOs())
        return options
}</span>

func (options *OptionsChain) WithArraySource(name string, array []string) *OptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, options_.WithArraySource(name, array))
        return options
}</span>

func (options *OptionsChain) WithPropertySources(propertySources ...properties.PropertiesSource) *OptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, options_.WithPropertySources(propertySources...))
        return options
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package environment

import (
        "sync/atomic"

        "github.com/guidomantilla/go-feather-lib/pkg/common/properties"
)

var singleton atomic.Value

func instance() Environment <span class="cov0" title="0">{
        value := singleton.Load()
        if value == nil </span><span class="cov0" title="0">{
                return Load()
        }</span>
        <span class="cov0" title="0">return value.(Environment)</span>
}

func Load(cmdArgs ...[]string) Environment <span class="cov0" title="0">{
        builder := OptionsChainBuilder().WithSSL().WithOs()
        if len(cmdArgs) &gt;= 1 </span><span class="cov0" title="0">{
                builder.WithCmd(cmdArgs[0])
        }</span>
        <span class="cov0" title="0">env := New(builder.Build())
        singleton.Store(env)
        return env</span>
}

func Value(property string) EnvVar <span class="cov0" title="0">{
        return instance().Value(property)
}</span>

func ValueOrDefault(property string, defaultValue string) EnvVar <span class="cov0" title="0">{
        return instance().ValueOrDefault(property, defaultValue)
}</span>

func PropertySources() []properties.PropertiesSource <span class="cov0" title="0">{
        return instance().PropertiesSources()
}</span>

func AppendPropertySources(propertySources ...properties.PropertiesSource) <span class="cov0" title="0">{
        instance().AppendPropertiesSources(propertySources...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package environment

import (
        "strconv"

        "github.com/guidomantilla/go-feather-lib/pkg/common/properties"
)

var (
        _ Environment = (*environment)(nil)
        _ Environment = (*MockEnvironment)(nil)
)

type Environment interface {
        Value(property string) EnvVar
        ValueOrDefault(property string, defaultValue string) EnvVar
        PropertiesSources() []properties.PropertiesSource
        AppendPropertiesSources(propertySources ...properties.PropertiesSource)
}

//

type EnvVar string

func NewEnvVar(value string) EnvVar <span class="cov0" title="0">{
        return EnvVar(value)
}</span>

func (envVar EnvVar) AsInt() (int, error) <span class="cov0" title="0">{
        value, err := strconv.Atoi(string(envVar))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func (envVar EnvVar) AsString() string <span class="cov0" title="0">{
        return string(envVar)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package errors

import (
        "errors"
        "strings"
)

func ErrJoin(errs ...error) error <span class="cov0" title="0">{
        return errors.New(strings.Replace(errors.Join(errs...).Error(), "\n", ": ", -1))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package log

import (
        "context"
        "io"
        "log/slog"
        "os"
        "strings"
        "sync/atomic"
)

var singleton atomic.Value

func instance() Logger[*slog.Logger] <span class="cov0" title="0">{
        value := singleton.Load()
        if value == nil </span><span class="cov0" title="0">{
                return Slog()
        }</span>
        <span class="cov0" title="0">return value.(Logger[*slog.Logger])</span>
}

func Slog(writers ...io.Writer) Logger[*slog.Logger] <span class="cov0" title="0">{
        level := os.Getenv("LOG_LEVEL")
        if level == "" </span><span class="cov0" title="0">{
                level = "INFO"
        }</span>
        <span class="cov0" title="0">logger := New(SlogLevelOff.ValueFromName(strings.ToUpper(level)), writers...)
        singleton.Store(logger)
        return logger</span>
}

//

func Trace(msg string, args ...any) <span class="cov0" title="0">{
        instance().Trace(context.Background(), msg, args...)
}</span>

func Debug(msg string, args ...any) <span class="cov0" title="0">{
        instance().Debug(context.Background(), msg, args...)
}</span>

func Info(msg string, args ...any) <span class="cov0" title="0">{
        instance().Info(context.Background(), msg, args...)
}</span>

func Warn(msg string, args ...any) <span class="cov0" title="0">{
        instance().Warn(context.Background(), msg, args...)
}</span>

func Error(msg string, args ...any) <span class="cov0" title="0">{
        instance().Error(context.Background(), msg, args...)
}</span>

func Fatal(msg string, args ...any) <span class="cov0" title="0">{
        instance().Fatal(context.Background(), msg, args...)
        os.Exit(1)
}</span>

//

func AsSlogLogger() *slog.Logger <span class="cov0" title="0">{
        return instance().Logger()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package log

import (
        "context"
        "log/slog"
)

var (
        _ slog.Handler = (*SlogFanoutHandler)(nil)
)

type SlogFanoutHandler struct {
        handlers []slog.Handler
}

func NewSlogFanoutHandler(handlers ...slog.Handler) slog.Handler <span class="cov0" title="0">{
        return &amp;SlogFanoutHandler{
                handlers: handlers,
        }
}</span>

func (h *SlogFanoutHandler) Enabled(ctx context.Context, l slog.Level) bool <span class="cov0" title="0">{
        for i := range h.handlers </span><span class="cov0" title="0">{
                if h.handlers[i].Enabled(ctx, l) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (h *SlogFanoutHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        for i := range h.handlers </span><span class="cov0" title="0">{
                if h.handlers[i].Enabled(ctx, r.Level) </span><span class="cov0" title="0">{
                        if err := h.handlers[i].Handle(ctx, r.Clone()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *SlogFanoutHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        for _, handler := range h.handlers </span><span class="cov0" title="0">{
                handler.WithAttrs(attrs)
        }</span>
        <span class="cov0" title="0">return NewSlogFanoutHandler(h.handlers...)</span>
}

func (h *SlogFanoutHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        for _, handler := range h.handlers </span><span class="cov0" title="0">{
                handler.WithGroup(name)
        }</span>
        <span class="cov0" title="0">return NewSlogFanoutHandler(h.handlers...)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package log

import (
        "context"
        "io"
        "log/slog"
        "os"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type slogLogger struct {
        internal *slog.Logger
}

func New(level SlogLevel, writers ...io.Writer) Logger[*slog.Logger] <span class="cov0" title="0">{
        assert.NotNil(level, "starting up - error setting up logger: level is nil")
        //assert.NotEmpty(writers, "starting up - error setting up logger: writers is empty")

        opts := &amp;slog.HandlerOptions{
                Level: level.ToSlogLevel(),
                ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr </span><span class="cov0" title="0">{
                        if a.Key == slog.LevelKey </span><span class="cov0" title="0">{
                                level := a.Value.Any().(slog.Level)
                                a.Value = slog.StringValue(SlogLevelOff.ValueFromSlogLevel(level).String())
                        }</span>
                        <span class="cov0" title="0">return a</span>
                },
        }

        <span class="cov0" title="0">handlers := make([]slog.Handler, 0)
        handlers = append(handlers, SlogTextFormat.Handler(os.Stdout, opts))
        for _, writer := range writers </span><span class="cov0" title="0">{
                handlers = append(handlers, SlogJsonFormat.Handler(writer, opts))
        }</span>
        <span class="cov0" title="0">internal := slog.New(NewSlogFanoutHandler(handlers...))
        slog.SetDefault(internal)

        return &amp;slogLogger{internal: internal}</span>
}

func (logger *slogLogger) Trace(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelTrace.ToSlogLevel(), msg, args...)
}</span>

func (logger *slogLogger) Debug(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelDebug.ToSlogLevel(), msg, args...)
}</span>

func (logger *slogLogger) Info(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelInfo.ToSlogLevel(), msg, args...)
}</span>

func (logger *slogLogger) Warn(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelWarning.ToSlogLevel(), msg, args...)
}</span>

func (logger *slogLogger) Error(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelError.ToSlogLevel(), msg, args...)
}</span>

func (logger *slogLogger) Fatal(ctx context.Context, msg string, args ...any) <span class="cov0" title="0">{
        logger.internal.Log(ctx, SlogLevelFatal.ToSlogLevel(), msg, args...)
        os.Exit(1)
}</span>

func (logger *slogLogger) Logger() *slog.Logger <span class="cov0" title="0">{
        return logger.internal
}</span>

//

const (
        SlogLevelTrace SlogLevel = iota
        SlogLevelDebug
        SlogLevelInfo
        SlogLevelWarning
        SlogLevelError
        SlogLevelFatal
        SlogLevelOff
)

type SlogLevel int

func (enum SlogLevel) String() string <span class="cov0" title="0">{

        switch enum </span>{
        case SlogLevelTrace:<span class="cov0" title="0">
                return "TRACE"</span>
        case SlogLevelDebug:<span class="cov0" title="0">
                return "DEBUG"</span>
        case SlogLevelInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case SlogLevelWarning:<span class="cov0" title="0">
                return "WARN"</span>
        case SlogLevelError:<span class="cov0" title="0">
                return "ERROR"</span>
        case SlogLevelFatal:<span class="cov0" title="0">
                return "FATAL"</span>
        case SlogLevelOff:<span class="cov0" title="0">
                return "OFF"</span>
        }
        <span class="cov0" title="0">return "OFF"</span>
}

func (enum SlogLevel) ToSlogLevel() slog.Level <span class="cov0" title="0">{
        switch enum </span>{
        case SlogLevelTrace:<span class="cov0" title="0">
                return slog.Level(-8)</span>
        case SlogLevelDebug:<span class="cov0" title="0">
                return slog.LevelDebug</span>
        case SlogLevelInfo:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case SlogLevelWarning:<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case SlogLevelError:<span class="cov0" title="0">
                return slog.LevelError</span>
        case SlogLevelFatal:<span class="cov0" title="0">
                return slog.Level(12)</span>
        case SlogLevelOff:<span class="cov0" title="0">
                return slog.Level(16)</span>
        }
        <span class="cov0" title="0">return slog.Level(16)</span>
}

func (enum SlogLevel) ValueFromName(slogLevel string) SlogLevel <span class="cov0" title="0">{
        switch slogLevel </span>{
        case "TRACE":<span class="cov0" title="0">
                return SlogLevelTrace</span>
        case "DEBUG":<span class="cov0" title="0">
                return SlogLevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                return SlogLevelInfo</span>
        case "WARN":<span class="cov0" title="0">
                return SlogLevelWarning</span>
        case "ERROR":<span class="cov0" title="0">
                return SlogLevelError</span>
        case "FATAL":<span class="cov0" title="0">
                return SlogLevelFatal</span>
        case "OFF":<span class="cov0" title="0">
                return SlogLevelOff</span>
        }
        <span class="cov0" title="0">return SlogLevelOff</span>
}

func (enum SlogLevel) ValueFromCardinal(slogLevel int) SlogLevel <span class="cov0" title="0">{
        switch slogLevel </span>{
        case int(SlogLevelTrace):<span class="cov0" title="0">
                return SlogLevelTrace</span>
        case int(SlogLevelDebug):<span class="cov0" title="0">
                return SlogLevelDebug</span>
        case int(SlogLevelInfo):<span class="cov0" title="0">
                return SlogLevelInfo</span>
        case int(SlogLevelWarning):<span class="cov0" title="0">
                return SlogLevelWarning</span>
        case int(SlogLevelError):<span class="cov0" title="0">
                return SlogLevelError</span>
        case int(SlogLevelFatal):<span class="cov0" title="0">
                return SlogLevelFatal</span>
        case int(SlogLevelOff):<span class="cov0" title="0">
                return SlogLevelOff</span>
        }
        <span class="cov0" title="0">return SlogLevelOff</span>
}

func (enum SlogLevel) ValueFromSlogLevel(slogLevel slog.Level) SlogLevel <span class="cov0" title="0">{
        switch slogLevel </span>{
        case slog.Level(-8):<span class="cov0" title="0">
                return SlogLevelTrace</span>
        case slog.LevelDebug:<span class="cov0" title="0">
                return SlogLevelDebug</span>
        case slog.LevelInfo:<span class="cov0" title="0">
                return SlogLevelInfo</span>
        case slog.LevelWarn:<span class="cov0" title="0">
                return SlogLevelWarning</span>
        case slog.LevelError:<span class="cov0" title="0">
                return SlogLevelError</span>
        case slog.Level(12):<span class="cov0" title="0">
                return SlogLevelFatal</span>
        case slog.Level(16):<span class="cov0" title="0">
                return SlogLevelOff</span>
        }
        <span class="cov0" title="0">return SlogLevelOff</span>
}

//

const (
        SlogTextFormat SlogFormat = iota
        SlogJsonFormat
)

type SlogFormat int

func (enum SlogFormat) String() string <span class="cov0" title="0">{
        switch enum </span>{
        case SlogTextFormat:<span class="cov0" title="0">
                return "TEXT"</span>
        case SlogJsonFormat:<span class="cov0" title="0">
                return "JSON"</span>
        }
        <span class="cov0" title="0">return "TEXT"</span>
}

func (enum SlogFormat) ValueFromName(loggerFormat string) SlogFormat <span class="cov0" title="0">{
        switch loggerFormat </span>{
        case "TEXT":<span class="cov0" title="0">
                return SlogTextFormat</span>
        case "JSON":<span class="cov0" title="0">
                return SlogJsonFormat</span>
        }
        <span class="cov0" title="0">return SlogTextFormat</span>
}

func (enum SlogFormat) ValueFromCardinal(loggerFormat int) SlogFormat <span class="cov0" title="0">{
        switch loggerFormat </span>{
        case int(SlogTextFormat):<span class="cov0" title="0">
                return SlogTextFormat</span>
        case int(SlogJsonFormat):<span class="cov0" title="0">
                return SlogJsonFormat</span>
        }
        <span class="cov0" title="0">return SlogTextFormat</span>
}

func (enum SlogFormat) Handler(w io.Writer, opts *slog.HandlerOptions) slog.Handler <span class="cov0" title="0">{
        switch enum </span>{
        case SlogTextFormat:<span class="cov0" title="0">
                return slog.NewTextHandler(w, opts)</span>
        case SlogJsonFormat:<span class="cov0" title="0">
                return slog.NewJSONHandler(w, opts)</span>
        }
        <span class="cov0" title="0">return slog.NewTextHandler(w, opts)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mocks

import (
        sqlmock "github.com/DATA-DOG/go-sqlmock"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/datasource"
)

func BuildMockGormTransactionHandler() (datasource.TransactionHandler[*gorm.DB], sqlmock.Sqlmock) <span class="cov0" title="0">{
        db, mock := BuildMockGormDatasource()
        return datasource.NewOrmTransactionHandler(db), mock
}</span>

func BuildMockGormDatasource() (datasource.Connection[*gorm.DB], sqlmock.Sqlmock) <span class="cov0" title="0">{
        db, mock, _ := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
        dialector := mysql.New(mysql.Config{
                Conn:                      db,
                DriverName:                "mock",
                SkipInitializeWithVersion: true,
        })
        context := datasource.NewContext("some url", "some username", "some password", "some server", "some service")
        connection := datasource.NewConnection(context, dialector, &amp;gorm.Config{})
        return connection, mock
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package properties

import (
        "sync/atomic"
)

var singleton atomic.Value

func instance() Properties <span class="cov0" title="0">{
        value := singleton.Load()
        if value == nil </span><span class="cov0" title="0">{
                return Load()
        }</span>
        <span class="cov0" title="0">return value.(Properties)</span>
}

func Load(slices ...[]string) Properties <span class="cov0" title="0">{
        withSlices := make([]Option, 0)
        for _, slice := range slices </span><span class="cov0" title="0">{
                withSlices = append(withSlices, FromSlice(slice))
        }</span>
        <span class="cov0" title="0">properties := New(withSlices...)
        singleton.Store(properties)
        return properties</span>
}

func Add(property string, value string) <span class="cov0" title="0">{
        instance().Add(property, value)
}</span>

func Get(property string) string <span class="cov0" title="0">{
        return instance().Get(property)
}</span>

func AsMap() map[string]string <span class="cov0" title="0">{
        return instance().AsMap()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package properties

import (
        "fmt"
        "strings"
        "sync"

        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

func FromSlice(array []string) Option <span class="cov0" title="0">{
        return func(properties *properties) </span><span class="cov0" title="0">{
                for _, env := range array </span><span class="cov0" title="0">{
                        pair := strings.SplitN(env, "=", 2)
                        if len(pair) != 2 </span><span class="cov0" title="0">{
                                log.Error(fmt.Sprintf("[%s=??] not a key value parameter. expected [key=value]", pair[0]))
                                continue</span>
                        }
                        <span class="cov0" title="0">properties.Add(pair[0], pair[1])</span>
                }
        }
}

type properties struct {
        internal map[string]string
        mu       sync.RWMutex
}

func New(options ...Option) Properties <span class="cov0" title="0">{
        properties := &amp;properties{
                internal: make(map[string]string),
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(properties)
        }</span>

        <span class="cov0" title="0">return properties</span>
}

func (p *properties) Add(property string, value string) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if p.internal[property] == "" </span><span class="cov0" title="0">{
                p.internal[property] = value
        }</span>
}

func (p *properties) Get(property string) string <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        return p.internal[property]
}</span>

func (p *properties) AsMap() map[string]string <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        return p.internal
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package properties

import (
        "fmt"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type propertiesSource struct {
        name       string
        properties Properties
        internal   map[string]any
}

func NewSource(name string, properties Properties) PropertiesSource <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("common properties: %s error - name is required", name))
        assert.NotNil(properties, fmt.Sprintf("common properties: %s error - handler is required", name))

        internalMap := make(map[string]any)
        internalMap["name"], internalMap["value"] = name, properties.AsMap()

        return &amp;propertiesSource{
                name:       name,
                properties: properties,
                internal:   internalMap,
        }
}</span>

func (source *propertiesSource) Get(property string) string <span class="cov0" title="0">{
        return source.properties.Get(property)
}</span>

func (source *propertiesSource) AsMap() map[string]any <span class="cov0" title="0">{
        return source.internal
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package rest

import (
        "net/http"
)

type Exception struct {
        Code    int      `json:"code,omitempty"`
        Message string   `json:"message,omitempty"`
        Errors  []string `json:"errors,omitempty"`
}

func Convert2StringArray(err ...error) []string <span class="cov0" title="0">{

        var errors []string
        if len(err) &gt;= 0 </span><span class="cov0" title="0">{
                for _, err2 := range err </span><span class="cov0" title="0">{
                        errors = append(errors, err2.Error())
                }</span>
        }
        <span class="cov0" title="0">return errors</span>
}

func BadRequestException(message string, err ...error) *Exception <span class="cov0" title="0">{

        return &amp;Exception{
                Message: message,
                Errors:  Convert2StringArray(err...),
                Code:    http.StatusBadRequest,
        }
}</span>

func UnauthorizedException(message string, err ...error) *Exception <span class="cov0" title="0">{

        return &amp;Exception{
                Message: message,
                Errors:  Convert2StringArray(err...),
                Code:    http.StatusUnauthorized,
        }
}</span>

func ForbiddenException(message string, err ...error) *Exception <span class="cov0" title="0">{

        return &amp;Exception{
                Message: message,
                Errors:  Convert2StringArray(err...),
                Code:    http.StatusForbidden,
        }
}</span>

func NotFoundException(message string, err ...error) *Exception <span class="cov0" title="0">{

        return &amp;Exception{
                Message: message,
                Errors:  Convert2StringArray(err...),
                Code:    http.StatusNotFound,
        }
}</span>

func InternalServerErrorException(message string, err ...error) *Exception <span class="cov0" title="0">{

        return &amp;Exception{
                Message: message,
                Errors:  Convert2StringArray(err...),
                Code:    http.StatusInternalServerError,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package server

import (
        "syscall"

        "github.com/qmdx00/lifecycle"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/environment"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/server"
)

func Run(name string, version string, fn func(application Application) error) <span class="cov0" title="0">{
        assert.NotEmpty(name, "server - error running: name is empty")
        assert.NotEmpty(version, "server - error running: version is empty")
        assert.NotNil(fn, "server - error running: function is nil")

        log.Slog()
        environment.Load()

        app := lifecycle.NewApp(
                lifecycle.WithName(name), lifecycle.WithVersion(version),
                lifecycle.WithSignal(syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGINT, syscall.SIGKILL),
        )

        app.Attach(server.BuildBaseServer())
        if err := fn(app); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>

        <span class="cov0" title="0">if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package ssl

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "os"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

func TLS(serverName string, caCertificate string, clientCertificate string, clientKey string) (*tls.Config, error) <span class="cov0" title="0">{
        assert.NotEmpty(serverName, "ssl - error setting up tls: serverName is empty")
        assert.NotEmpty(caCertificate, "ssl - error setting up tls: caCertificate is empty")
        assert.NotEmpty(clientCertificate, "ssl - error setting up tls: clientCertificate is empty")
        assert.NotEmpty(clientKey, "ssl - error setting up tls: clientKey is empty")

        var err error

        var caCert []byte
        if caCert, err = os.ReadFile(caCertificate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ca certificate: %s", err.Error())
        }</span>

        <span class="cov0" title="0">caCertPool := x509.NewCertPool()
        caCertPool.AppendCertsFromPEM(caCert)

        var cert tls.Certificate
        if cert, err = tls.LoadX509KeyPair(clientCertificate, clientKey); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client certificate: %s", err.Error())
        }</span>

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                RootCAs:            caCertPool,
                Certificates:       []tls.Certificate{cert},
                ServerName:         serverName,
                InsecureSkipVerify: false,
                MinVersion:         tls.VersionTLS12,
        }

        return tlsConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package utils

import (
        "fmt"
        "reflect"
        "strings"
)

func ToString(value any) string <span class="cov0" title="0">{
        return strings.TrimSpace(fmt.Sprintf("%v", value))
}</span>

//

func IsEmpty(object any) bool <span class="cov0" title="0">{
        objValue := reflect.ValueOf(object)
        if !objValue.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">switch objValue.Kind() </span>{
        // collection types are empty when they have no element
        case reflect.Chan, reflect.Map, reflect.Slice, reflect.Array:<span class="cov0" title="0">
                return objValue.Len() == 0</span>
        // pointers are empty if nil or if the value they point to is empty
        case reflect.Ptr:<span class="cov0" title="0">
                if objValue.IsNil() </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">deref := objValue.Elem().Interface()
                return IsEmpty(deref)</span>
        case reflect.String:<span class="cov0" title="0">
                value := objValue.String()
                return strings.TrimSpace(value) == ""</span>
        // for all other types, compare against the zero value
        // array types are empty when they match their zero-initialized state
        default:<span class="cov0" title="0">
                zero := reflect.Zero(objValue.Type())
                return reflect.DeepEqual(object, zero.Interface())</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package validation

import (
        "fmt"
)

type ErrFieldMustBeUndefined struct {
        structName string
        field      string
}

func NewErrFieldMustBeUndefined(structName string, field string) *ErrFieldMustBeUndefined <span class="cov0" title="0">{
        return &amp;ErrFieldMustBeUndefined{structName: structName, field: field}
}</span>

func (e *ErrFieldMustBeUndefined) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s must be undefined", e.structName, e.field)
}</span>

type ErrFieldIsRequired struct {
        structName string
        field      string
}

func NewErrFieldIsRequired(structName string, field string) *ErrFieldIsRequired <span class="cov0" title="0">{
        return &amp;ErrFieldIsRequired{structName: structName, field: field}
}</span>

func (e *ErrFieldIsRequired) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s.%s is required", e.structName, e.field)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package validation

import (
        "reflect"
        "strings"
)

// Structs

func ValidateStructMustBeUndefined(structName string, field string, value any) error <span class="cov0" title="0">{
        if !reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                return NewErrFieldMustBeUndefined(structName, field)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateStructIsRequired(structName string, field string, value any) error <span class="cov0" title="0">{
        if reflect.ValueOf(value).IsNil() </span><span class="cov0" title="0">{
                return NewErrFieldIsRequired(structName, field)
        }</span>

        <span class="cov0" title="0">reflectedValue := reflect.ValueOf(value)
        if reflect.TypeOf(reflectedValue.Interface()).String() == "*string" </span><span class="cov0" title="0">{
                str := reflectedValue.Interface().(*string)
                if *(str) == "" || strings.TrimSpace(*(str)) == "" </span><span class="cov0" title="0">{
                        return NewErrFieldIsRequired(structName, field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Fields

type AllowedFieldTypes interface {
        *int64 | *float64 | *string | *bool
}

func ValidateFieldMustBeUndefined[T AllowedFieldTypes](structName string, field string, value T) error <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                return NewErrFieldMustBeUndefined(structName, field)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ValidateFieldIsRequired[T AllowedFieldTypes](structName string, field string, value T) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return NewErrFieldIsRequired(structName, field)
        }</span>

        <span class="cov0" title="0">reflectedValue := reflect.ValueOf(value)
        if reflect.TypeOf(reflectedValue.Interface()).String() == "*string" </span><span class="cov0" title="0">{
                str := reflectedValue.Interface().(*string)
                if *(str) == "" || strings.TrimSpace(*(str)) == "" </span><span class="cov0" title="0">{
                        return NewErrFieldIsRequired(structName, field)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package datasource

import (
        "fmt"

        retry "github.com/avast/retry-go/v4"
        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type connection struct {
        context   Context
        database  *gorm.DB
        dialector gorm.Dialector
        opts      []gorm.Option
}

func NewConnection(context Context, dialector gorm.Dialector, opts ...gorm.Option) Connection[*gorm.DB] <span class="cov0" title="0">{
        assert.NotNil(context, "starting up - error setting up datasource connection: context is nil")
        assert.NotNil(dialector, "starting up - error setting up datasource connection: dialector is nil")
        //assert.NotEmpty(opts, "starting up - error setting up datasource connection: opts is empty")

        return &amp;connection{
                context:   context,
                database:  nil,
                dialector: dialector,
                opts:      opts,
        }
}</span>

func (datasource *connection) Connect() (*gorm.DB, error) <span class="cov0" title="0">{

        if datasource.database == nil </span><span class="cov0" title="0">{

                err := retry.Do(datasource.connect, retry.Attempts(5),
                        retry.OnRetry(func(n uint, err error) </span><span class="cov0" title="0">{
                                log.Info("datasource connection - failed to connect")
                                log.Info(fmt.Sprintf("datasource connection - trying reconnection to %s/%s", datasource.context.Server(), datasource.context.Service()))
                        }</span>),
                )

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return datasource.database, nil</span>
}

func (datasource *connection) connect() error <span class="cov0" title="0">{

        var err error
        if datasource.database, err = gorm.Open(datasource.dialector, datasource.opts...); err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                return ErrDBConnectionFailed(err)
        }</span>
        <span class="cov0" title="0">log.Info(fmt.Sprintf("datasource connection - connected to %s/%s", datasource.context.Server(), datasource.context.Service()))

        return nil</span>
}

func (datasource *connection) Close() <span class="cov0" title="0">{

        if datasource.database != nil </span><span class="cov0" title="0">{
                log.Debug("datasource connection - closing connection")
                sqlDB, _ := datasource.database.DB()
                if err := sqlDB.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("datasource connection - failed to close connection to %s/%s: %s", datasource.context.Server(), datasource.context.Service(), err.Error()))
                }</span>
        }
        <span class="cov0" title="0">datasource.database = nil
        log.Debug(fmt.Sprintf("datasource connection - closed connection to to %s/%s", datasource.context.Server(), datasource.context.Service()))</span>
}

func (datasource *connection) Context() Context <span class="cov0" title="0">{
        return datasource.context
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package datasource

import (
        "strings"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type context_ struct {
        url     string
        server  string
        service string
}

func NewContext(url string, username string, password string, server string, service string) Context <span class="cov0" title="0">{
        assert.NotEmpty(url, "starting up - error setting up datasource context: url is empty")
        assert.NotEmpty(username, "starting up - error setting up datasource context: username is empty")
        assert.NotEmpty(password, "starting up - error setting up datasource context: password is empty")
        assert.NotEmpty(server, "starting up - error setting up datasource context: server is empty")
        assert.NotEmpty(service, "starting up - error setting up datasource context: service is empty")

        url = strings.Replace(url, ":username", username, 1)
        url = strings.Replace(url, ":password", password, 1)
        url = strings.Replace(url, ":server", server, 1)
        url = strings.Replace(url, ":service", service, 1)

        return &amp;context_{
                url:     url,
                server:  server,
                service: service,
        }
}</span>

func (context *context_) Url() string <span class="cov0" title="0">{
        return context.url
}</span>

func (context *context_) Server() string <span class="cov0" title="0">{
        return context.server
}</span>

func (context *context_) Service() string <span class="cov0" title="0">{
        return context.service
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package datasource

import (
        "errors"
        "fmt"
)

func ErrDBConnectionFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("db connection failed: %s", errors.Join(errs...).Error())
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package datasource

import (
        "context"

        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type transactionHandler struct {
        connection Connection[*gorm.DB]
}

func NewOrmTransactionHandler(connection Connection[*gorm.DB]) TransactionHandler[*gorm.DB] <span class="cov0" title="0">{
        assert.NotNil(connection, "starting up - error setting up orm transaction handler: connection is nil")

        return &amp;transactionHandler{connection: connection}
}</span>

func (handler *transactionHandler) HandleTransaction(ctx context.Context, fn TransactionHandlerFn[*gorm.DB]) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "transaction handler - error handling transaction: context is nil")
        assert.NotNil(fn, "transaction handler - error handling transaction: transaction handler function is nil")

        dbx, err := handler.connection.Connect()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                return err
        }</span>
        <span class="cov0" title="0">return dbx.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                return fn(ctx, tx)
        }</span>)
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package integration

import (
        "context"
        "time"

        "github.com/guidomantilla/go-feather-lib/pkg/integration/messaging"
)

func BaseMessageChannel[T any](name string) messaging.MessageChannel[T] <span class="cov0" title="0">{
        queueChannel := messaging.NewQueueChannel[T](name, 10000)
        senderHandler, receiverHandler := BaseSenderChannel[T](name, queueChannel.Send), BaseReceiverChannel[T](name, queueChannel.Receive)
        return messaging.NewPassThroughChannel(name, senderHandler, receiverHandler)
}</span>

func BaseReceiverChannel[T any](name string, handler messaging.ReceiverHandler[T]) messaging.ReceiverChannel[T] <span class="cov0" title="0">{
        var channel messaging.ReceiverChannel[T]
        channel = messaging.NewFunctionAdapterReceiverChannel(name, handler)
        channel = messaging.NewHeadersValidatorReceiverChannel(name, channel, NullHeadersValidatorValidator())
        channel = messaging.NewTimeoutReceiverChannel(name, channel)
        channel = messaging.NewLoggedReceiverChannel(name, channel)
        return channel
}</span>

func BaseSenderChannel[T any](name string, handler messaging.SenderHandler[T]) messaging.SenderChannel[T] <span class="cov0" title="0">{
        var channel messaging.SenderChannel[T]
        channel = messaging.NewFunctionAdapterSenderChannel(name, handler)
        channel = messaging.NewHeadersValidatorSenderChannel(name, channel, NullHeadersValidatorValidator())
        channel = messaging.NewTimeoutSenderChannel(name, channel)
        channel = messaging.NewLoggedSenderChannel(name, channel)
        return channel
}</span>

//

func NullReceiverHandler[T any](ctx context.Context, timeout time.Duration) (messaging.Message[T], error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func NullReceiverChannel[T any](name string) messaging.ReceiverChannel[T] <span class="cov0" title="0">{
        return messaging.NewFunctionAdapterReceiverChannel(name, NullReceiverHandler[T])
}</span>

//

func NullSenderHandler[T any](ctx context.Context, timeout time.Duration, message messaging.Message[T]) error <span class="cov0" title="0">{
        return nil
}</span>

func NullSenderChannel[T any](name string) messaging.SenderChannel[T] <span class="cov0" title="0">{
        return messaging.NewFunctionAdapterSenderChannel(name, NullSenderHandler[T])
}</span>

//

func NullHeadersValidatorHandler(ctx context.Context, headers messaging.Headers) error <span class="cov0" title="0">{
        return nil
}</span>

func NullHeadersValidatorValidator() messaging.HeadersValidator <span class="cov0" title="0">{
        return messaging.NewFunctionAdapterHeadersValidator(NullHeadersValidatorHandler)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

// PassThroughChannel

type PassThroughChannel[T any] struct {
        name     string
        sender   SenderChannel[T]
        receiver ReceiverChannel[T]
}

func NewPassThroughChannel[T any](name string, sender SenderChannel[T], receiver ReceiverChannel[T]) *PassThroughChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(sender, fmt.Sprintf("integration messaging: %s error - sender is required", name))
        assert.NotNil(receiver, fmt.Sprintf("integration messaging: %s error - receiver is required", name))
        return &amp;PassThroughChannel[T]{
                name:     name,
                sender:   sender,
                receiver: receiver,
        }
}</span>

func (channel *PassThroughChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">return channel.sender.Send(ctx, timeout, message)</span>
}

func (channel *PassThroughChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">return channel.receiver.Receive(ctx, timeout)</span>
}

func (channel *PassThroughChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

// QueueChannel

type QueueChannel[T any] struct {
        name      string
        internal  chan Message[T]
        closeChan chan struct{}
}

func NewQueueChannel[T any](name string, size int) *QueueChannel[T] <span class="cov0" title="0">{
        return &amp;QueueChannel[T]{
                name:      name,
                internal:  make(chan Message[T], size),
                closeChan: make(chan struct{}),
        }
}</span>

func (channel *QueueChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                message.Headers().Add(HeaderExpired, "true")
                message.Headers().Add("x-error-detail", ctx.Err().Error())
                return fmt.Errorf("message pipeline timeout: %v", ctx.Err().Error())</span>
        case &lt;-channel.closeChan:<span class="cov0" title="0">
                return fmt.Errorf("message pipeline %s is closed", channel.name)</span>
        default:<span class="cov0" title="0">
                channel.internal &lt;- message
                return nil</span>
        }
}

func (channel *QueueChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("message pipeline timeout: %v", ctx.Err().Error())</span>
        case &lt;-channel.closeChan:<span class="cov0" title="0">
                return nil, fmt.Errorf("message pipeline %s is closed", channel.name)</span>
        case message := &lt;-channel.internal:<span class="cov0" title="0">
                return message, nil</span>
        }
}

func (channel *QueueChannel[T]) Close() <span class="cov0" title="0">{
        channel.closeChan &lt;- struct{}{}
        time.Sleep(2 * time.Second)
        close(channel.internal)
        close(channel.closeChan)
}</span>

func (channel *QueueChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

// FunctionAdapterReceiverChannel

type FunctionAdapterReceiverChannel[T any] struct {
        name    string
        handler ReceiverHandler[T]
}

func NewFunctionAdapterReceiverChannel[T any](name string, handler ReceiverHandler[T]) *FunctionAdapterReceiverChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(handler, fmt.Sprintf("integration messaging: %s error - handler is required", name))
        return &amp;FunctionAdapterReceiverChannel[T]{
                name:    name,
                handler: handler,
        }
}</span>

func (handler *FunctionAdapterReceiverChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", handler.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", handler.name)
        }</span>

        <span class="cov0" title="0">return handler.handler(ctx, timeout)</span>
}

func (handler *FunctionAdapterReceiverChannel[T]) Name() string <span class="cov0" title="0">{
        return handler.name
}</span>

// PassThroughReceiverChannel

type PassThroughReceiverChannel[T any] struct {
        name     string
        receiver ReceiverChannel[T]
}

func NewPassThroughReceiverChannel[T any](name string, receiver ReceiverChannel[T]) *PassThroughReceiverChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(receiver, fmt.Sprintf("integration messaging: %s error - receiver is required", name))
        return &amp;PassThroughReceiverChannel[T]{
                name:     name,
                receiver: receiver,
        }
}</span>

func (channel *PassThroughReceiverChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">return channel.receiver.Receive(ctx, timeout)</span>
}

// HeadersValidatorReceiverChannel

type HeadersValidatorReceiverChannel[T any] struct {
        name       string
        receiver   ReceiverChannel[T]
        validators []HeadersValidator
}

func NewHeadersValidatorReceiverChannel[T any](name string, receiver ReceiverChannel[T], validators ...HeadersValidator) *HeadersValidatorReceiverChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(receiver, fmt.Sprintf("integration messaging: %s error - receiver is required", name))
        assert.NotNil(validators, fmt.Sprintf("integration messaging: %s error - validators are required", name))
        assert.NotEmpty(validators, fmt.Sprintf("integration messaging: %s error - validators are required", name))
        return &amp;HeadersValidatorReceiverChannel[T]{
                name:       name,
                receiver:   receiver,
                validators: validators,
        }
}</span>

func (channel *HeadersValidatorReceiverChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">var err error
        var message Message[T]
        if message, err = channel.receiver.Receive(ctx, timeout); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, validator := range channel.validators </span><span class="cov0" title="0">{
                if err = validator.Validate(ctx, message.Headers()); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return message, nil</span>

}

func (channel *HeadersValidatorReceiverChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

// TimeoutReceiverChannel

type TimeoutReceiverChannel[T any] struct {
        name     string
        receiver ReceiverChannel[T]
}

func NewTimeoutReceiverChannel[T any](name string, receiver ReceiverChannel[T]) *TimeoutReceiverChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(receiver, fmt.Sprintf("integration messaging: %s error - receiver is required", name))
        return &amp;TimeoutReceiverChannel[T]{
                name:     name,
                receiver: receiver,
        }
}</span>

func (channel *TimeoutReceiverChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        responseChan := make(chan *response[T])
        go func(responseChan chan *response[T]) </span><span class="cov0" title="0">{
                defer close(responseChan)
                responseChan &lt;- convert(channel.receiver.Receive(ctx, timeout))
        }</span>(responseChan)

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, fmt.Errorf("message receiving timeout: %v", ctx.Err().Error())</span>
        case response := &lt;-responseChan:<span class="cov0" title="0">
                return response.message, response.err</span>
        }
}

func (channel *TimeoutReceiverChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

type response[T any] struct {
        message Message[T]
        err     error
}

func convert[T any](message Message[T], err error) *response[T] <span class="cov0" title="0">{
        return &amp;response[T]{
                message: message,
                err:     err,
        }
}</span>

// LoggedReceiverChannel

type LoggedReceiverChannel[T any] struct {
        name     string
        receiver ReceiverChannel[T]
}

func NewLoggedReceiverChannel[T any](name string, receiver ReceiverChannel[T]) *LoggedReceiverChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(receiver, fmt.Sprintf("integration messaging: %s error - receiver is required", name))
        return &amp;LoggedReceiverChannel[T]{
                name:     name,
                receiver: receiver,
        }
}</span>

func (channel *LoggedReceiverChannel[T]) Receive(ctx context.Context, timeout time.Duration) (Message[T], error) <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("integration messaging: %s error - for receiving a message, timeout is required", channel.name)
        }</span>

        <span class="cov0" title="0">var err error
        var message Message[T]
        log.Trace(fmt.Sprintf("integration messaging: %s receiving message", channel.name))
        if message, err = channel.receiver.Receive(ctx, timeout); err != nil </span><span class="cov0" title="0">{
                log.Trace(fmt.Sprintf("integration messaging: %s error - message not received", channel.name))
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Trace(fmt.Sprintf("integration messaging: %s message received: %v", channel.name, message))
        return message, nil</span>
}

func (channel *LoggedReceiverChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package messaging

import (
        "context"
        "fmt"
        "time"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

// FunctionAdapterSenderChannel

type FunctionAdapterSenderChannel[T any] struct {
        name    string
        handler SenderHandler[T]
}

func NewFunctionAdapterSenderChannel[T any](name string, handler SenderHandler[T]) *FunctionAdapterSenderChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(handler, fmt.Sprintf("integration messaging: %s error - handler is required", name))
        return &amp;FunctionAdapterSenderChannel[T]{
                name:    name,
                handler: handler,
        }
}</span>

func (handler *FunctionAdapterSenderChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", handler.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", handler.name)
        }</span>

        <span class="cov0" title="0">return handler.handler(ctx, timeout, message)</span>
}

func (handler *FunctionAdapterSenderChannel[T]) Name() string <span class="cov0" title="0">{
        return handler.name
}</span>

// PassThroughSenderChannel

type PassThroughSenderChannel[T any] struct {
        name   string
        sender SenderChannel[T]
}

func NewPassThroughSenderChannel[T any](name string, sender SenderChannel[T]) *PassThroughSenderChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(sender, fmt.Sprintf("integration messaging: %s error - sender is required", name))
        return &amp;PassThroughSenderChannel[T]{
                name:   name,
                sender: sender,
        }
}</span>

func (channel *PassThroughSenderChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">return channel.sender.Send(ctx, timeout, message)</span>
}

func (channel *PassThroughSenderChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

// HeadersValidatorSenderChannel

type HeadersValidatorSenderChannel[T any] struct {
        name       string
        sender     SenderChannel[T]
        validators []HeadersValidator
}

func NewHeadersValidatorSenderChannel[T any](name string, sender SenderChannel[T], validators ...HeadersValidator) *HeadersValidatorSenderChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(sender, fmt.Sprintf("integration messaging: %s error - sender is required", name))
        assert.NotNil(validators, fmt.Sprintf("integration messaging: %s error - validators are required", name))
        assert.NotEmpty(validators, fmt.Sprintf("integration messaging: %s error - validators are required", name))
        return &amp;HeadersValidatorSenderChannel[T]{
                name:       name,
                sender:     sender,
                validators: validators,
        }
}</span>

func (channel *HeadersValidatorSenderChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">var err error
        for _, validator := range channel.validators </span><span class="cov0" title="0">{
                if err = validator.Validate(ctx, message.Headers()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return channel.sender.Send(ctx, timeout, message)</span>
}

func (channel *HeadersValidatorSenderChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

// TimeoutSenderChannel

type TimeoutSenderChannel[T any] struct {
        name   string
        sender SenderChannel[T]
}

func NewTimeoutSenderChannel[T any](name string, sender SenderChannel[T]) *TimeoutSenderChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(sender, fmt.Sprintf("integration messaging: %s error - sender is required", name))
        return &amp;TimeoutSenderChannel[T]{
                name:   name,
                sender: sender,
        }
}</span>

func (channel *TimeoutSenderChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        errChan := make(chan error)
        go func(errChan chan error) </span><span class="cov0" title="0">{
                defer close(errChan)
                errChan &lt;- channel.sender.Send(ctx, timeout, message)
        }</span>(errChan)

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                message.Headers().Add(HeaderExpired, "true")
                message.Headers().Add("x-error-detail", ctx.Err().Error())
                return fmt.Errorf("message sending timeout: %v", ctx.Err().Error())</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        }
}

func (channel *TimeoutSenderChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>

// LoggedSenderChannel

type LoggedSenderChannel[T any] struct {
        name   string
        sender SenderChannel[T]
}

func NewLoggedSenderChannel[T any](name string, sender SenderChannel[T]) *LoggedSenderChannel[T] <span class="cov0" title="0">{
        assert.NotEmpty(name, fmt.Sprintf("integration messaging: %s error - name is required", name))
        assert.NotNil(sender, fmt.Sprintf("integration messaging: %s error - sender is required", name))
        return &amp;LoggedSenderChannel[T]{
                name:   name,
                sender: sender,
        }
}</span>

func (channel *LoggedSenderChannel[T]) Send(ctx context.Context, timeout time.Duration, message Message[T]) error <span class="cov0" title="0">{

        if ctx == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, context is required", channel.name)
        }</span>

        <span class="cov0" title="0">if message == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("integration messaging: %s error - for sending a message, message is required", channel.name)
        }</span>

        <span class="cov0" title="0">log.Trace(fmt.Sprintf("integration messaging: sending message: %v", message))
        if err := channel.sender.Send(ctx, timeout, message); err != nil </span><span class="cov0" title="0">{
                log.Trace(fmt.Sprintf("integration messaging: error - message not sent: %v", message))
                return err
        }</span>

        <span class="cov0" title="0">log.Trace(fmt.Sprintf("integration messaging: message sent: %v", message))
        return nil</span>
}

func (channel *LoggedSenderChannel[T]) Name() string <span class="cov0" title="0">{
        return channel.name
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package messaging

import (
        "fmt"

        "github.com/guidomantilla/go-feather-lib/pkg/common/errors"
)

func ErrMessagingFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("messaging failed: %s", errors.ErrJoin(errs...).Error())
}</span>

func ErrMessageDeliveryFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("message delivery failed: %s", errors.ErrJoin(errs...).Error())
}</span>

func ErrMessageHandlingFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("message handling failed: %s", errors.ErrJoin(errs...).Error())
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package messaging

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type HeadersConfig struct {
        Id                 uuid.UUID
        MessageType        string
        Timestamp          time.Time
        Expired            bool
        TimeToLive         time.Duration
        ContentType        string
        OriginChannel      string
        DestinationChannel string
        ReplyChannel       string
        ErrorChannel       string
        Headers            map[string]string
}

type BaseHeaders struct {
        internal           map[string]string
        id                 uuid.UUID
        messageType        string
        timestamp          time.Time
        expired            bool
        timeToLive         time.Duration
        contentType        string
        originChannel      string
        destinationChannel string
        replyChannel       string
        errorChannel       string
}

func NewBaseHeaders(options ...HeadersOptions) *BaseHeaders <span class="cov0" title="0">{
        headers := &amp;BaseHeaders{
                internal:           make(map[string]string),
                id:                 uuid.New(),
                messageType:        "",
                timestamp:          time.Now(),
                expired:            false,
                timeToLive:         -1,
                contentType:        "",
                originChannel:      "",
                destinationChannel: "",
                replyChannel:       "",
                errorChannel:       "",
        }

        headers.Add(HeaderErrorChannel, headers.errorChannel)
        headers.Add(HeaderReplyChannel, headers.replyChannel)
        headers.Add(HeaderDestinationChannel, headers.destinationChannel)
        headers.Add(HeaderOriginChannel, headers.originChannel)
        headers.Add(HeaderContentType, headers.contentType)
        headers.Add(HeaderExpiredTimeToLive, headers.timeToLive.String())
        headers.Add(HeaderExpired, strconv.FormatBool(headers.expired))
        headers.Add(HeaderTimestamp, headers.timestamp.Format(time.RFC3339))
        headers.Add(HeaderMessageType, headers.messageType)
        headers.Add(HeaderId, headers.id.String())

        for _, option := range options </span><span class="cov0" title="0">{
                option(headers)
        }</span>

        <span class="cov0" title="0">return headers</span>
}

func NewBaseHeadersFromConfig(config *HeadersConfig) *BaseHeaders <span class="cov0" title="0">{
        assert.NotNil(config, fmt.Sprintf("integration messaging: %s error - config is required", "base-headers"))
        return NewBaseHeaders(NewHeadersOptionsFromConfig(config))
}</span>

//

func (headers *BaseHeaders) Id() uuid.UUID <span class="cov0" title="0">{
        return uuid.MustParse(headers.internal[HeaderId])
}</span>

func (headers *BaseHeaders) MessageType() string <span class="cov0" title="0">{
        return headers.internal[HeaderMessageType]
}</span>

func (headers *BaseHeaders) Timestamp() time.Time <span class="cov0" title="0">{
        value, _ := time.Parse(time.RFC3339, headers.internal[HeaderTimestamp])
        return value
}</span>

func (headers *BaseHeaders) Expired() bool <span class="cov0" title="0">{
        value, _ := strconv.ParseBool(headers.internal[HeaderExpired])
        return value
}</span>

func (headers *BaseHeaders) TimeToLive() time.Duration <span class="cov0" title="0">{
        value, _ := time.ParseDuration(headers.internal[HeaderExpiredTimeToLive])
        return value
}</span>

func (headers *BaseHeaders) ContentType() string <span class="cov0" title="0">{
        return headers.internal[HeaderContentType]
}</span>

func (headers *BaseHeaders) OriginChannel() string <span class="cov0" title="0">{
        return headers.internal[HeaderOriginChannel]
}</span>

func (headers *BaseHeaders) DestinationChannel() string <span class="cov0" title="0">{
        return headers.internal[HeaderDestinationChannel]
}</span>

func (headers *BaseHeaders) ReplyChannel() string <span class="cov0" title="0">{
        return headers.internal[HeaderReplyChannel]
}</span>

func (headers *BaseHeaders) ErrorChannel() string <span class="cov0" title="0">{
        return headers.internal[HeaderErrorChannel]
}</span>

//

func (headers *BaseHeaders) Add(property string, value string) <span class="cov0" title="0">{

        property, value = strings.TrimSpace(property), strings.TrimSpace(value)
        if property == "" || value == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">property = strings.ToLower(property)
        if property == HeaderId </span><span class="cov0" title="0">{
                headers.id = uuid.MustParse(value)
        }</span>
        <span class="cov0" title="0">if property == HeaderMessageType </span><span class="cov0" title="0">{
                headers.messageType = value
        }</span>
        <span class="cov0" title="0">if property == HeaderTimestamp </span><span class="cov0" title="0">{
                headers.timestamp, _ = time.Parse(time.RFC3339, value)
        }</span>
        <span class="cov0" title="0">if property == HeaderExpired </span><span class="cov0" title="0">{
                headers.expired, _ = strconv.ParseBool(value)
        }</span>
        <span class="cov0" title="0">if property == HeaderExpiredTimeToLive </span><span class="cov0" title="0">{
                headers.timeToLive, _ = time.ParseDuration(value)
        }</span>
        <span class="cov0" title="0">if property == HeaderContentType </span><span class="cov0" title="0">{
                headers.contentType = value
        }</span>
        <span class="cov0" title="0">if property == HeaderOriginChannel </span><span class="cov0" title="0">{
                headers.originChannel = value
        }</span>
        <span class="cov0" title="0">if property == HeaderDestinationChannel </span><span class="cov0" title="0">{
                headers.destinationChannel = value
        }</span>
        <span class="cov0" title="0">if property == HeaderReplyChannel </span><span class="cov0" title="0">{
                headers.replyChannel = value
        }</span>
        <span class="cov0" title="0">if property == HeaderErrorChannel </span><span class="cov0" title="0">{
                headers.errorChannel = value
        }</span>

        <span class="cov0" title="0">headers.internal[property] = value</span>
}

func (headers *BaseHeaders) Get(property string) string <span class="cov0" title="0">{
        return headers.internal[property]
}</span>

func (headers *BaseHeaders) AsMap() map[string]string <span class="cov0" title="0">{
        return headers.internal
}</span>

func (headers *BaseHeaders) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v", headers.internal)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package messaging

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

var headersOptions = NewHeadersOptions()

func NewHeadersOptions() HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span>{<span class="cov0" title="0">
        }</span>
}

func NewHeadersOptionsFromConfig(config *HeadersConfig) HeadersOptions <span class="cov0" title="0">{
        assert.NotNil(config, fmt.Sprintf("integration messaging: %s error - config is required", "headers-options"))
        builder := HeadersOptionsChainBuilder().Id(config.Id).MessageType(config.MessageType).Timestamp(config.Timestamp).
                Expired(config.Expired).TimeToLive(config.TimeToLive).ContentType(config.ContentType).
                OriginChannel(config.OriginChannel).DestinationChannel(config.DestinationChannel).
                ReplyChannel(config.ReplyChannel).ErrorChannel(config.ErrorChannel)
        for key, value := range config.Headers </span><span class="cov0" title="0">{
                builder = builder.Add(key, value)
        }</span>
        <span class="cov0" title="0">return builder.Build()</span>
}

func (options HeadersOptions) Id(id uuid.UUID) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if id != uuid.Nil </span><span class="cov0" title="0">{
                        headers.Add(HeaderId, id.String())
                }</span>
        }
}

func (options HeadersOptions) MessageType(messageType string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if strings.TrimSpace(messageType) != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderMessageType, messageType)
                }</span>
        }
}

func (options HeadersOptions) Timestamp(timestamp time.Time) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if !timestamp.IsZero() </span><span class="cov0" title="0">{
                        headers.Add(HeaderTimestamp, timestamp.Format(time.RFC3339))
                }</span>
        }
}

func (options HeadersOptions) Expired(expired bool) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                headers.Add(HeaderExpired, strconv.FormatBool(expired))
        }</span>
}

func (options HeadersOptions) TimeToLive(timeToLive time.Duration) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if timeToLive &gt; 0 </span><span class="cov0" title="0">{
                        headers.Add(HeaderExpiredTimeToLive, timeToLive.String())
                }</span>
        }
}

func (options HeadersOptions) ContentType(contentType string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if strings.TrimSpace(contentType) != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderContentType, contentType)
                }</span>
        }
}

func (options HeadersOptions) OriginChannel(originChannel string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if strings.TrimSpace(originChannel) != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderOriginChannel, originChannel)
                }</span>
        }
}

func (options HeadersOptions) DestinationChannel(destinationChannel string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if strings.TrimSpace(destinationChannel) != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderDestinationChannel, destinationChannel)
                }</span>
        }
}

func (options HeadersOptions) ReplyChannel(replyChannel string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if replyChannel != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderReplyChannel, replyChannel)
                }</span>
        }
}

func (options HeadersOptions) ErrorChannel(errorChannel string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if errorChannel != "" </span><span class="cov0" title="0">{
                        headers.Add(HeaderErrorChannel, errorChannel)
                }</span>
        }
}

func (options HeadersOptions) Add(property string, value string) HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                if strings.TrimSpace(property) != "" &amp;&amp; strings.TrimSpace(value) != "" </span><span class="cov0" title="0">{
                        headers.Add(strings.ToLower(property), value)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package messaging

import (
        "time"

        "github.com/google/uuid"
)

type BaseHeadersOptionsChain struct {
        chain []HeadersOptions
}

func HeadersOptionsChainBuilder() HeadersOptionsChain <span class="cov0" title="0">{
        return &amp;BaseHeadersOptionsChain{
                chain: make([]HeadersOptions, 0),
        }
}</span>

func (options *BaseHeadersOptionsChain) Build() HeadersOptions <span class="cov0" title="0">{
        return func(headers Headers) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(headers)
                }</span>
        }
}

func (options *BaseHeadersOptionsChain) Id(id uuid.UUID) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.Id(id))
        return options
}</span>

func (options *BaseHeadersOptionsChain) MessageType(messageType string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.MessageType(messageType))
        return options
}</span>

func (options *BaseHeadersOptionsChain) Timestamp(timestamp time.Time) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.Timestamp(timestamp))
        return options
}</span>

func (options *BaseHeadersOptionsChain) Expired(expired bool) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.Expired(expired))
        return options
}</span>

func (options *BaseHeadersOptionsChain) TimeToLive(timeToLive time.Duration) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.TimeToLive(timeToLive))
        return options
}</span>

func (options *BaseHeadersOptionsChain) ContentType(contentType string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.ContentType(contentType))
        return options
}</span>

func (options *BaseHeadersOptionsChain) OriginChannel(originChannel string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.OriginChannel(originChannel))
        return options
}</span>

func (options *BaseHeadersOptionsChain) DestinationChannel(destinationChannel string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.DestinationChannel(destinationChannel))
        return options
}</span>

func (options *BaseHeadersOptionsChain) ReplyChannel(replyChannel string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.ReplyChannel(replyChannel))
        return options
}</span>

func (options *BaseHeadersOptionsChain) ErrorChannel(errorChannel string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.ErrorChannel(errorChannel))
        return options
}</span>

func (options *BaseHeadersOptionsChain) Add(property string, value string) HeadersOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, headersOptions.Add(property, value))
        return options
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package messaging

import (
        "context"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

//

type FunctionAdapterHeadersValidator struct {
        validator HeadersValidatorHandler
}

func NewFunctionAdapterHeadersValidator(validator HeadersValidatorHandler) *FunctionAdapterHeadersValidator <span class="cov0" title="0">{
        assert.NotNil(validator, "integration messaging error - validator is required")
        return &amp;FunctionAdapterHeadersValidator{
                validator: validator,
        }
}</span>

func (validator *FunctionAdapterHeadersValidator) Validate(ctx context.Context, headers Headers) error <span class="cov0" title="0">{
        return validator.validator(ctx, headers)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package messaging

import (
        "fmt"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type BaseMessage[T any] struct {
        headers Headers
        payload T
}

func NewBaseMessage[T any](headers Headers, payload T) *BaseMessage[T] <span class="cov0" title="0">{
        assert.NotNil(headers, fmt.Sprintf("integration messaging: %s error - headers is required", "base-message"))
        assert.NotNil(payload, fmt.Sprintf("integration messaging: %s error - payload is required", "base-message"))
        return &amp;BaseMessage[T]{
                headers: headers,
                payload: payload,
        }
}</span>

func (message *BaseMessage[T]) Headers() Headers <span class="cov0" title="0">{
        return message.headers
}</span>

func (message *BaseMessage[T]) Payload() T <span class="cov0" title="0">{
        return message.payload
}</span>

func (message *BaseMessage[T]) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("headers:%v, payload:%T[%v]", message.headers, message.payload, message.payload)
}</span>

//

type BaseErrorPayload struct {
        code    string
        message string
        errors  []string
}

func NewBaseErrorPayload(code string, message string, errors ...string) *BaseErrorPayload <span class="cov0" title="0">{
        assert.NotEmpty(code, fmt.Sprintf("integration messaging: %s error - code is required", "base-message"))
        assert.NotEmpty(message, fmt.Sprintf("integration messaging: %s error - message is required", "base-message"))
        return &amp;BaseErrorPayload{
                code:    code,
                message: message,
                errors:  errors,
        }
}</span>

func (payload *BaseErrorPayload) Code() string <span class="cov0" title="0">{
        return payload.code
}</span>

func (payload *BaseErrorPayload) Message() string <span class="cov0" title="0">{
        return payload.message
}</span>

func (payload *BaseErrorPayload) Errors() []string <span class="cov0" title="0">{
        return payload.errors
}</span>

func (payload *BaseErrorPayload) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("code:%v, message:%v, errors:%v", payload.code, payload.message, payload.errors)
}</span>

func (payload *BaseErrorPayload) Error() string <span class="cov0" title="0">{
        return payload.String()
}</span>

//

type BaseErrorMessage[T any] struct {
        headers Headers
        payload ErrorPayload
        message Message[T]
}

func NewBaseErrorMessage[T any](headers Headers, payload ErrorPayload, message Message[T]) *BaseErrorMessage[T] <span class="cov0" title="0">{
        assert.NotNil(headers, fmt.Sprintf("integration messaging: %s error - headers is required", "base-message"))
        assert.NotNil(payload, fmt.Sprintf("integration messaging: %s error - payload is required", "base-message"))
        assert.NotNil(message, fmt.Sprintf("integration messaging: %s error - message is required", "base-message"))
        return &amp;BaseErrorMessage[T]{
                headers: headers,
                payload: payload,
                message: message,
        }
}</span>

func (message *BaseErrorMessage[T]) Headers() Headers <span class="cov0" title="0">{
        return message.headers
}</span>

func (message *BaseErrorMessage[T]) Payload() ErrorPayload <span class="cov0" title="0">{
        return message.payload
}</span>

func (message *BaseErrorMessage[T]) Message() Message[T] <span class="cov0" title="0">{
        return message.message
}</span>

func (message *BaseErrorMessage[T]) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("headers:%v, payload:%T[%v], message:%T[%v]", message.headers, message.payload, message.payload, message.message, message.message)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package messaging

import (
        "context"
        "time"
)

//

type MoreComplexSenderChannel[T any] struct {
        SenderChannel[T]
}

func NewMoreComplexSenderChannel[T any](handler SenderHandler[T]) *MoreComplexSenderChannel[T] <span class="cov0" title="0">{
        return &amp;MoreComplexSenderChannel[T]{
                SenderChannel: NewFunctionAdapterSenderChannel("", handler),
        }
}</span>

func (channel *MoreComplexSenderChannel[T]) Send(ctx context.Context, message Message[T], timeout time.Duration) error <span class="cov0" title="0">{
        return channel.SenderChannel.Send(ctx, timeout, message)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package rabbitmq

import (
        "fmt"
        "sync"
        "time"

        retry "github.com/avast/retry-go/v4"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type Connection[T messaging.ConnectionTypes] struct {
        context          messaging.Context
        connectionDialer messaging.ConnectionDialer[T]
        connection       T
        mu               sync.RWMutex
}

func NewConnection[T messaging.ConnectionTypes](context messaging.Context, connectionDialer messaging.ConnectionDialer[T]) *Connection[T] <span class="cov0" title="0">{
        assert.NotNil(context, "starting up - error setting up rabbitmq connection: context is nil")
        assert.NotNil(connectionDialer, "starting up - error setting up rabbitmq connection: connectionDialer is nil")

        connection := &amp;Connection[T]{
                context:          context,
                connectionDialer: connectionDialer,
        }

        return connection
}</span>

func (connection *Connection[T]) Connect() (T, error) <span class="cov0" title="0">{

        connection.mu.Lock()
        defer connection.mu.Unlock()

        if connection.connection != nil &amp;&amp; !connection.connection.IsClosed() </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq connection - already connected to %s", connection.context.Server()))
                return connection.connection, nil
        }</span>

        <span class="cov0" title="0">err := retry.Do(connection.connect, retry.Attempts(5), retry.Delay(messaging.Delay),
                retry.LastErrorOnly(true), retry.OnRetry(func(n uint, err error) </span><span class="cov0" title="0">{
                        log.Warn(fmt.Sprintf("rabbitmq connection - failed to connect: %s", err.Error()))
                }</span>),
        )

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("rabbitmq connection - failed connection to %s", connection.context.Server()))
                return nil, err
        }</span>

        <span class="cov0" title="0">return connection.connection, nil</span>
}

func (connection *Connection[T]) connect() error <span class="cov0" title="0">{

        var err error
        if connection.connection, err = connection.connectionDialer(connection.context.Url()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Info(fmt.Sprintf("rabbitmq connection - connected to %s", connection.context.Server()))

        return nil</span>
}

func (connection *Connection[T]) Close() <span class="cov0" title="0">{
        time.Sleep(messaging.Delay)

        if connection.connection != nil &amp;&amp; !connection.connection.IsClosed() </span><span class="cov0" title="0">{
                log.Debug("rabbitmq connection - closing connection")
                if err := connection.connection.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("rabbitmq connection - failed to close connection to %s: %s", connection.context.Server(), err.Error()))
                }</span>
        }
        <span class="cov0" title="0">connection.connection = nil
        log.Debug(fmt.Sprintf("rabbitmq connection - closed connection to %s", connection.context.Server()))</span>
}

func (connection *Connection[T]) Context() messaging.Context <span class="cov0" title="0">{
        return connection.context
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package rabbitmq

import (
        "crypto/tls"

        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

func AMQPDialer() messaging.ConnectionDialer[*amqp.Connection] <span class="cov0" title="0">{
        return func(url string) (*amqp.Connection, error) </span><span class="cov0" title="0">{
                return amqp.Dial(url)
        }</span>
}

func AMQPDialerTLS(amqps *tls.Config) messaging.ConnectionDialer[*amqp.Connection] <span class="cov0" title="0">{
        return func(url string) (*amqp.Connection, error) </span><span class="cov0" title="0">{
                return amqp.DialTLS(url, amqps)
        }</span>
}

func StreamsDialer() messaging.ConnectionDialer[*stream.Environment] <span class="cov0" title="0">{
        return func(url string) (*stream.Environment, error) </span><span class="cov0" title="0">{
                return stream.NewEnvironment(stream.NewEnvironmentOptions().SetUri(url))
        }</span>
}

func StreamsDialerTLS(streams *tls.Config) messaging.ConnectionDialer[*stream.Environment] <span class="cov0" title="0">{
        return func(url string) (*stream.Environment, error) </span><span class="cov0" title="0">{
                return stream.NewEnvironment(stream.NewEnvironmentOptions().SetUri(url).SetTLSConfig(streams))
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "sync"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/common/utils"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type AmqpConsumer struct {
        connection messaging.Connection[*amqp.Connection]
        listener   messaging.Listener[*amqp.Delivery]
        channel    *amqp.Channel
        queue      amqp.Queue
        name       string
        consumer   string
        autoAck    bool
        noLocal    bool
        durable    bool
        autoDelete bool
        exclusive  bool
        noWait     bool
        args       amqp.Table
        mu         sync.RWMutex
}

func NewAmqpConsumer(connection messaging.Connection[*amqp.Connection], name string, options ...AmqpConsumerOptions) *AmqpConsumer <span class="cov0" title="0">{
        assert.NotNil(connection, "starting up - error setting up rabbitmq amqp consumer: connection is nil")
        assert.NotEmpty(name, "starting up - error setting up rabbitmq amqp consumer: name is empty")

        consumer := &amp;AmqpConsumer{
                connection: connection,
                listener:   NewAmqpListener(),
                name:       name,
                consumer:   "consumer-" + name,
                autoAck:    false,
                noLocal:    false,
                durable:    false,
                autoDelete: false,
                exclusive:  false,
                noWait:     false,
                args:       nil,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(consumer)
        }</span>
        <span class="cov0" title="0">consumer.autoAck = false

        return consumer</span>
}

func (consumer *AmqpConsumer) Consume(ctx context.Context) (messaging.Event, error) <span class="cov0" title="0">{

        consumer.mu.Lock()
        defer consumer.mu.Unlock()

        var err error
        var connection *amqp.Connection
        if connection, err = consumer.connection.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq consumer - failed connection to queue %s: %s", consumer.name, err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">if !(consumer.channel != nil &amp;&amp; !consumer.channel.IsClosed()) </span><span class="cov0" title="0">{
                if consumer.channel, err = connection.Channel(); err != nil </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq consumer - failed connection to queue %s: %s", consumer.name, err.Error()))
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if consumer.queue, err = consumer.channel.QueueDeclare(consumer.name, consumer.durable, consumer.autoDelete, consumer.exclusive, consumer.noWait, consumer.args); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq consumer - failed connection to queue %s: %s", consumer.name, err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq consumer - connected to queue %s", consumer.name))

        var deliveries &lt;-chan amqp.Delivery
        if deliveries, err = consumer.channel.ConsumeWithContext(ctx, consumer.name, consumer.consumer, consumer.autoAck, consumer.exclusive, consumer.noLocal, consumer.noWait, consumer.args); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq consumer - failed comsuming from queue: %s", err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">closeChannel := make(chan string)
        closeHandler := func(ctx context.Context, listener messaging.Listener[*amqp.Delivery], channel *amqp.Channel, queue string, closeChannel chan string) </span><span class="cov0" title="0">{
                var err error
                for message := range deliveries </span><span class="cov0" title="0">{
                        go func(ctx context.Context, message amqp.Delivery) </span><span class="cov0" title="0">{
                                log.Debug(fmt.Sprintf("rabbitmq consumer - message received: %s", message.Body))
                                if err := listener.OnMessage(ctx, &amp;message); err != nil </span><span class="cov0" title="0">{
                                        log.Debug(fmt.Sprintf("rabbitmq consumer - failed to process message: %s", err.Error()))
                                        if err := message.Nack(false, true); err != nil </span><span class="cov0" title="0">{
                                                log.Debug(fmt.Sprintf("rabbitmq consumer - failed to nack message: %s", err.Error()))
                                        }</span>
                                        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq consumer - nack message: %s", err.Error()))
                                        return</span>
                                }
                                <span class="cov0" title="0">if err := message.Ack(false); err != nil </span><span class="cov0" title="0">{
                                        log.Debug(fmt.Sprintf("rabbitmq consumer - failed to ack message: %s", err.Error()))
                                        return
                                }</span>
                                <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq consumer - ack message: %s", err.Error()))</span>
                        }(ctx, message)
                }
                <span class="cov0" title="0">if err = channel.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq consumer - failed to close channel to queue %s: %s", queue, err.Error()))
                        return
                }</span>
                <span class="cov0" title="0">close(closeChannel)
                log.Debug(fmt.Sprintf("rabbitmq consumer - disconected from queue %s", queue))</span>
        }

        <span class="cov0" title="0">go closeHandler(ctx, consumer.listener, consumer.channel, consumer.name, closeChannel)
        return closeChannel, nil</span>
}

func (consumer *AmqpConsumer) Close() <span class="cov0" title="0">{
        time.Sleep(messaging.Delay)

        if consumer.channel != nil &amp;&amp; !consumer.channel.IsClosed() </span><span class="cov0" title="0">{
                log.Debug("rabbitmq consumer - closing connection")
                if err := consumer.channel.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("rabbitmq consumer - failed to close connection to queue %s: %s", consumer.name, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">consumer.channel = nil
        consumer.connection.Close()
        log.Debug(fmt.Sprintf("rabbitmq consumer - closed connection to queue %s", consumer.name))</span>
}

func (consumer *AmqpConsumer) Context() messaging.Context <span class="cov0" title="0">{
        return consumer.connection.Context()
}</span>

func (consumer *AmqpConsumer) Set(property string, value any) <span class="cov0" title="0">{
        if utils.IsEmpty(property) || utils.IsEmpty(value) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch property </span>{
        case "listener":<span class="cov0" title="0">
                if value != nil </span><span class="cov0" title="0">{
                        consumer.listener = value.(messaging.Listener[*amqp.Delivery])
                }</span>
        case "autoAck":<span class="cov0" title="0">
                consumer.autoAck = value.(bool)</span>
        case "noLocal":<span class="cov0" title="0">
                consumer.noLocal = value.(bool)</span>
        case "durable":<span class="cov0" title="0">
                consumer.durable = value.(bool)</span>
        case "autoDelete":<span class="cov0" title="0">
                consumer.autoDelete = value.(bool)</span>
        case "exclusive":<span class="cov0" title="0">
                consumer.exclusive = value.(bool)</span>
        case "noWait":<span class="cov0" title="0">
                consumer.noWait = value.(bool)</span>
        case "args":<span class="cov0" title="0">
                if value != nil </span><span class="cov0" title="0">{
                        consumer.args = value.(amqp.Table)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package rabbitmq

import (
        amqp "github.com/rabbitmq/amqp091-go"

        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

var amqpConsumerOptions = NewAmqpConsumerOptions()

func NewAmqpConsumerOptions() AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span>{<span class="cov0" title="0">
        }</span>
}

type AmqpConsumerOptions func(consumer messaging.Consumer)

func (options AmqpConsumerOptions) WithRabbitMQListener(listener messaging.Listener[*amqp.Delivery]) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("listener", listener)
        }</span>
}

func (options AmqpConsumerOptions) WithAutoAck(autoAck bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("autoAck", autoAck)
        }</span>
}

func (options AmqpConsumerOptions) WithNoLocal(noLocal bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("noLocal", noLocal)
        }</span>
}

func (options AmqpConsumerOptions) WithDurable(durable bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("durable", durable)
        }</span>
}

func (options AmqpConsumerOptions) WithAutoDelete(autoDelete bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("autoDelete", autoDelete)
        }</span>
}

func (options AmqpConsumerOptions) WithExclusive(exclusive bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("exclusive", exclusive)
        }</span>
}

func (options AmqpConsumerOptions) WithNoWait(noWait bool) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("noWait", noWait)
        }</span>
}

func (options AmqpConsumerOptions) WithArgs(args amqp.Table) AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                consumer.Set("args", args)
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package rabbitmq

import (
        amqp "github.com/rabbitmq/amqp091-go"

        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type AmqpConsumerOptionsChain struct {
        chain []AmqpConsumerOptions
}

func AmqpConsumerOptionsChainBuilder() *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        return &amp;AmqpConsumerOptionsChain{
                chain: make([]AmqpConsumerOptions, 0),
        }
}</span>

func (options *AmqpConsumerOptionsChain) Build() AmqpConsumerOptions <span class="cov0" title="0">{
        return func(consumer messaging.Consumer) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(consumer)
                }</span>
        }
}

func (options *AmqpConsumerOptionsChain) WithRabbitMQListener(listener messaging.Listener[*amqp.Delivery]) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithRabbitMQListener(listener))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithAutoAck(autoAck bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithAutoAck(autoAck))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithNoLocal(noLocal bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithNoLocal(noLocal))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithDurable(durable bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithDurable(durable))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithAutoDelete(autoDelete bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithAutoDelete(autoDelete))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithExclusive(exclusive bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithExclusive(exclusive))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithNoWait(noWait bool) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithNoWait(noWait))
        return options
}</span>

func (options *AmqpConsumerOptionsChain) WithArgs(args amqp.Table) *AmqpConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpConsumerOptions.WithArgs(args))
        return options
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package rabbitmq

import (
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/amqp"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type StreamsConsumer struct {
        connection      messaging.Connection[*stream.Environment]
        listener        messaging.Listener[*amqp.Message]
        environment     *stream.Environment
        name            string
        consumer        string
        streamOptions   *stream.StreamOptions
        consumerOptions *stream.ConsumerOptions
        messagesHandler stream.MessagesHandler
        mu              sync.RWMutex
}

func NewStreamsConsumer(connection messaging.Connection[*stream.Environment], name string, options ...StreamsConsumerOptions) *StreamsConsumer <span class="cov0" title="0">{
        assert.NotNil(connection, "starting up - error setting up rabbitmq streams consumer: connection is nil")
        assert.NotEmpty(name, "starting up - error setting up rabbitmq streams consumer: name is empty")

        listener := NewStreamsListener()
        consumer := &amp;StreamsConsumer{
                connection:      connection,
                name:            name,
                consumer:        "consumer-" + name,
                streamOptions:   stream.NewStreamOptions(),
                consumerOptions: stream.NewConsumerOptions().SetConsumerName("consumer-" + name),
                listener:        listener,
                messagesHandler: func(consumerContext stream.ConsumerContext, message *amqp.Message) </span><span class="cov0" title="0">{
                        go func(consumerContext stream.ConsumerContext, message *amqp.Message) </span><span class="cov0" title="0">{
                                log.Debug(fmt.Sprintf("rabbitmq streams consumer - message received: %s", message.Data))
                                ctx := context.WithValue(context.Background(), stream.ConsumerContext{}, consumerContext)
                                if err := listener.OnMessage(ctx, message); err != nil </span><span class="cov0" title="0">{
                                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed to process message: %s", err.Error()))
                                        return
                                }</span>
                        }(consumerContext, message)
                },
        }

        <span class="cov0" title="0">for _, option := range options </span><span class="cov0" title="0">{
                option(consumer)
        }</span>

        <span class="cov0" title="0">consumer.consumerOptions.SetConsumerName(consumer.consumer)
        consumer.consumerOptions.SetManualCommit()

        return consumer</span>
}

func (streams *StreamsConsumer) Consume(ctx context.Context) (messaging.Event, error) <span class="cov0" title="0">{
        streams.mu.Lock()
        defer streams.mu.Unlock()

        var err error
        if streams.environment, err = streams.connection.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed connection to stream %s: %s", streams.name, err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">var streamExists bool
        if streamExists, err = streams.environment.StreamExists(streams.name); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed connection to stream %s: %s", streams.name, err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">if !streamExists </span><span class="cov0" title="0">{
                if err = streams.environment.DeclareStream(streams.name, streams.streamOptions); err != nil </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed connection to stream %s: %s", streams.name, err.Error()))
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq streams consumer - connected to stream %s", streams.name))

        var storedOffset int64
        if storedOffset, err = streams.environment.QueryOffset(streams.consumer, streams.name); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, stream.OffsetNotFoundError) </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed to query offset from stream %s: %s", streams.name, err.Error()))
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - setting up offset to FIRST from stream %s", streams.name))
                        streams.consumerOptions.SetOffset(stream.OffsetSpecification{}.First())
                }</span> else<span class="cov0" title="0"> {
                        newOffset := storedOffset + 1
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - setting up offset to %d from stream %s", newOffset, streams.name))
                        streams.consumerOptions.SetOffset(stream.OffsetSpecification{}.Offset(newOffset))
                }</span>
        }

        <span class="cov0" title="0">var consumer *stream.Consumer
        if consumer, err = streams.environment.NewConsumer(streams.name, streams.messagesHandler, streams.consumerOptions); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed comsuming from stream %s: %s", streams.name, err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">closeChannel := make(chan string)
        closeHandler := func(consumer *stream.Consumer, stream string, closeChannel chan string) </span><span class="cov0" title="0">{
                var err error
                for range consumer.NotifyClose() </span><span class="cov0" title="0">{
                        if err := consumer.StoreOffset(); err != nil </span><span class="cov0" title="0">{
                                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed to store consumer offset from stream %s: %s", stream, err.Error()))
                                return
                        }</span>
                        <span class="cov0" title="0">if err = consumer.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed to close consumer from stream %s: %s", stream, err.Error()))
                                return
                        }</span>
                        <span class="cov0" title="0">close(closeChannel)</span>
                }
                <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq streams consumer - disconected from stream %s", stream))</span>
        }

        <span class="cov0" title="0">go closeHandler(consumer, streams.name, closeChannel)
        return closeChannel, nil</span>
}

func (streams *StreamsConsumer) Close() <span class="cov0" title="0">{
        time.Sleep(messaging.Delay)

        if streams.environment != nil &amp;&amp; !streams.environment.IsClosed() </span><span class="cov0" title="0">{
                log.Debug("rabbitmq streams consumer - closing connection")
                if err := streams.environment.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("rabbitmq streams consumer - failed to close connection to stream %s: %s", streams.name, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">streams.environment = nil
        streams.connection.Close()
        log.Debug(fmt.Sprintf("rabbitmq streams consumer - closed connection to stream %s", streams.name))</span>
}

func (streams *StreamsConsumer) Context() messaging.Context <span class="cov0" title="0">{
        return streams.connection.Context()
}</span>

func (streams *StreamsConsumer) Set(property string, value any) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package rabbitmq

import (
        "context"
        "fmt"

        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/amqp"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

var streamsConsumerOptions = NewStreamsConsumerOptions()

func NewStreamsConsumerOptions() StreamsConsumerOptions <span class="cov0" title="0">{
        return func(consumer *StreamsConsumer) </span>{<span class="cov0" title="0">
        }</span>
}

type StreamsConsumerOptions func(*StreamsConsumer)

func (options StreamsConsumerOptions) WithStreamOptions(soptions *stream.StreamOptions) StreamsConsumerOptions <span class="cov0" title="0">{
        return func(consumer *StreamsConsumer) </span><span class="cov0" title="0">{
                consumer.streamOptions = soptions
        }</span>
}

func (options StreamsConsumerOptions) WithConsumerOptions(coptions *stream.ConsumerOptions) StreamsConsumerOptions <span class="cov0" title="0">{
        return func(consumer *StreamsConsumer) </span><span class="cov0" title="0">{
                consumer.consumerOptions = coptions
        }</span>
}

func (options StreamsConsumerOptions) WithStreamsListener(listener messaging.Listener[*amqp.Message]) StreamsConsumerOptions <span class="cov0" title="0">{
        return func(consumer *StreamsConsumer) </span><span class="cov0" title="0">{
                consumer.listener = listener
                consumer.messagesHandler = func(consumerContext stream.ConsumerContext, message *amqp.Message) </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - message received: %s", message.Data))
                        if err := listener.OnMessage(context.Background(), message); err != nil </span><span class="cov0" title="0">{
                                log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed to process message: %s", err.Error()))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package rabbitmq

import (
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/amqp"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type StreamsConsumerOptionsChain struct {
        chain []StreamsConsumerOptions
}

func StreamsConsumerOptionsChainBuilder() *StreamsConsumerOptionsChain <span class="cov0" title="0">{
        return &amp;StreamsConsumerOptionsChain{
                chain: make([]StreamsConsumerOptions, 0),
        }
}</span>

func (options *StreamsConsumerOptionsChain) Build() StreamsConsumerOptions <span class="cov0" title="0">{
        return func(consumer *StreamsConsumer) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(consumer)
                }</span>
        }
}

func (options *StreamsConsumerOptionsChain) WithStreamOptions(soptions *stream.StreamOptions) *StreamsConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, streamsConsumerOptions.WithStreamOptions(soptions))
        return options
}</span>

func (options *StreamsConsumerOptionsChain) WithConsumerOptions(coptions *stream.ConsumerOptions) *StreamsConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, streamsConsumerOptions.WithConsumerOptions(coptions))
        return options
}</span>

func (options *StreamsConsumerOptionsChain) WithStreamsListener(listener messaging.Listener[*amqp.Message]) *StreamsConsumerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, streamsConsumerOptions.WithStreamsListener(listener))
        return options
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package rabbitmq

import (
        "strings"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/utils"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type context_ struct {
        url     string
        server  string
        service string
        vhost   string
}

func NewContext(url string, username string, password string, server string, options ...ContextOptions) messaging.Context <span class="cov0" title="0">{
        assert.NotEmpty(url, "starting up - error setting up messaging context: url is empty")
        assert.NotEmpty(username, "starting up - error setting up messaging context: username is empty")
        assert.NotEmpty(password, "starting up - error setting up messaging context: password is empty")
        assert.NotEmpty(server, "starting up - error setting up messaging context: server is empty")

        url = strings.Replace(url, ":username", username, 1)
        url = strings.Replace(url, ":password", password, 1)
        url = strings.Replace(url, ":server", server, 1)

        context := &amp;context_{
                url:    url,
                server: server,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(context)
        }</span>

        <span class="cov0" title="0">if context.service != "" &amp;&amp; context.vhost == "" </span><span class="cov0" title="0">{
                context.url = strings.Replace(url, ":service", context.service, 1)
        }</span>

        <span class="cov0" title="0">if context.service == "" &amp;&amp; context.vhost != "" </span><span class="cov0" title="0">{
                context.url = strings.Replace(url, ":vhost", context.vhost, 1)
        }</span>

        <span class="cov0" title="0">return context</span>
}

func (context *context_) Url() string <span class="cov0" title="0">{
        return context.url
}</span>

func (context *context_) Server() string <span class="cov0" title="0">{

        if context.service != "" &amp;&amp; context.vhost == "" </span><span class="cov0" title="0">{
                return context.server + context.service
        }</span>

        <span class="cov0" title="0">if context.service == "" &amp;&amp; context.vhost != "" </span><span class="cov0" title="0">{
                return context.server + context.vhost
        }</span>

        <span class="cov0" title="0">return context.server</span>
}

func (context *context_) Set(property string, value string) <span class="cov0" title="0">{
        if utils.IsEmpty(property) || utils.IsEmpty(value) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch property </span>{
        case "service":<span class="cov0" title="0">
                context.service = strings.TrimSpace(value)</span>
        case "vhost":<span class="cov0" title="0">
                context.vhost = strings.TrimSpace(value)</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package rabbitmq

import "github.com/guidomantilla/go-feather-lib/pkg/messaging"

var contextOptions = NewContextOption()

func NewContextOption() ContextOptions <span class="cov0" title="0">{
        return func(context messaging.Context) </span>{<span class="cov0" title="0">
        }</span>
}

type ContextOptions func(context messaging.Context)

func (option ContextOptions) WithService(service string) ContextOptions <span class="cov0" title="0">{
        return func(context messaging.Context) </span><span class="cov0" title="0">{
                context.Set("service", service)
        }</span>
}

func (option ContextOptions) WithVhost(vhost string) ContextOptions <span class="cov0" title="0">{
        return func(context messaging.Context) </span><span class="cov0" title="0">{
                context.Set("vhost", vhost)
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package rabbitmq

import "github.com/guidomantilla/go-feather-lib/pkg/messaging"

type ContextOptionsChain struct {
        chain []ContextOptions
}

func NewContextOptionChain() *ContextOptionsChain <span class="cov0" title="0">{
        return &amp;ContextOptionsChain{
                chain: make([]ContextOptions, 0),
        }
}</span>

func (options *ContextOptionsChain) Build() ContextOptions <span class="cov0" title="0">{
        return func(context messaging.Context) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(context)
                }</span>
        }
}

func (options *ContextOptionsChain) WithService(service string) *ContextOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, contextOptions.WithService(service))
        return options
}</span>

func (options *ContextOptionsChain) WithVhost(vhost string) *ContextOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, contextOptions.WithVhost(vhost))
        return options
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"

        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type AmqpListener struct {
}

func NewAmqpListener() *AmqpListener <span class="cov0" title="0">{
        return &amp;AmqpListener{}
}</span>

func (listener *AmqpListener) OnMessage(ctx context.Context, message *amqp.Delivery) error <span class="cov0" title="0">{

        log.Info(fmt.Sprintf("Received a message: %s", message.Body))
        time.Sleep(5 * time.Second)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "time"

        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/amqp"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type StreamsListener struct {
}

func NewStreamsListener() *StreamsListener <span class="cov0" title="0">{
        return &amp;StreamsListener{}
}</span>

func (listener *StreamsListener) OnMessage(ctx context.Context, message *amqp.Message) error <span class="cov0" title="0">{

        var consumerContext stream.ConsumerContext
        anyContext := ctx.Value(stream.ConsumerContext{})
        if anyContext != nil </span><span class="cov0" title="0">{
                consumerContext = anyContext.(stream.ConsumerContext)
        }</span>
        <span class="cov0" title="0">log.Debug(fmt.Sprintf("Received a consumerContext: %s", consumerContext.Consumer.GetName()))
        log.Info(fmt.Sprintf("Received a message: %s", message.Data))
        time.Sleep(5 * time.Second)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "sync"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type AmqpProducer struct {
        connection messaging.Connection[*amqp.Connection]
        channel    *amqp.Channel
        name       string
        exchange   string
        mandatory  bool
        immediate  bool
        mu         sync.RWMutex
}

func NewAmqpProducer(connection messaging.Connection[*amqp.Connection], name string, options ...AmqpProducerOptions) *AmqpProducer <span class="cov0" title="0">{
        assert.NotNil(connection, "starting up - error setting up rabbitmq amqp producer: connection is nil")
        assert.NotEmpty(name, "starting up - error setting up rabbitmq amqp producer: name is empty")

        producer := &amp;AmqpProducer{
                connection: connection,
                name:       name,
                exchange:   "",
                mandatory:  false,
                immediate:  false,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(producer)
        }</span>

        <span class="cov0" title="0">return producer</span>
}

func (producer *AmqpProducer) Produce(ctx context.Context, message *amqp.Publishing) error <span class="cov0" title="0">{
        producer.mu.Lock()
        defer producer.mu.Unlock()

        var err error
        var connection *amqp.Connection
        if connection, err = producer.connection.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq producer - failed connection to queue %s: %s", producer.name, err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">if !(producer.channel != nil &amp;&amp; !producer.channel.IsClosed()) </span><span class="cov0" title="0">{
                if producer.channel, err = connection.Channel(); err != nil </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq producer - failed connection to queue %s: %s", producer.name, err.Error()))
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq producer - publishing to queue %s", producer.name))
        if err = producer.channel.PublishWithContext(ctx, producer.exchange, producer.name, producer.mandatory, producer.immediate, *message); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq producer - failed publishing to queue: %s", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq producer - published to queue %s", producer.name))
        return nil</span>
}

func (producer *AmqpProducer) Close() <span class="cov0" title="0">{
        time.Sleep(messaging.Delay)

        if producer.channel != nil &amp;&amp; !producer.channel.IsClosed() </span><span class="cov0" title="0">{
                log.Debug("rabbitmq producer - closing connection")
                if err := producer.channel.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("rabbitmq producer - failed to close connection to queue %s: %s", producer.name, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">producer.channel = nil
        producer.connection.Close()
        log.Debug(fmt.Sprintf("rabbitmq producer - closed connection to queue %s", producer.name))</span>
}

func (producer *AmqpProducer) Context() messaging.Context <span class="cov0" title="0">{
        return producer.connection.Context()
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package rabbitmq

var amqpProducerOptions = NewAmqpProducerOptions()

func NewAmqpProducerOptions() AmqpProducerOptions <span class="cov0" title="0">{
        return func(producer *AmqpProducer) </span>{<span class="cov0" title="0">
        }</span>
}

type AmqpProducerOptions func(*AmqpProducer)

func (options AmqpProducerOptions) WithExchange(exchange string) AmqpProducerOptions <span class="cov0" title="0">{
        return func(producer *AmqpProducer) </span><span class="cov0" title="0">{
                producer.exchange = exchange
        }</span>
}

func (options AmqpProducerOptions) WithMandatory(mandatory bool) AmqpProducerOptions <span class="cov0" title="0">{
        return func(producer *AmqpProducer) </span><span class="cov0" title="0">{
                producer.mandatory = mandatory
        }</span>
}

func (options AmqpProducerOptions) WithImmediate(immediate bool) AmqpProducerOptions <span class="cov0" title="0">{
        return func(producer *AmqpProducer) </span><span class="cov0" title="0">{
                producer.immediate = immediate
        }</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package rabbitmq

type AmqpProducerOptionsChain struct {
        chain []AmqpProducerOptions
}

func AmqpProducerOptionsChainBuilder() *AmqpProducerOptionsChain <span class="cov0" title="0">{
        return &amp;AmqpProducerOptionsChain{
                chain: make([]AmqpProducerOptions, 0),
        }
}</span>

func (options *AmqpProducerOptionsChain) Build() AmqpProducerOptions <span class="cov0" title="0">{
        return func(producer *AmqpProducer) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(producer)
                }</span>
        }
}

func (options *AmqpProducerOptionsChain) WithExchange(exchange string) *AmqpProducerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpProducerOptions.WithExchange(exchange))
        return options
}</span>

func (options *AmqpProducerOptionsChain) WithMandatory(mandatory bool) *AmqpProducerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpProducerOptions.WithMandatory(mandatory))
        return options
}</span>

func (options *AmqpProducerOptionsChain) WithImmediate(immediate bool) *AmqpProducerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, amqpProducerOptions.WithImmediate(immediate))
        return options
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package rabbitmq

import (
        "context"
        "fmt"
        "sync"
        "time"

        samqp "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/amqp"
        "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type StreamsProducer struct {
        connection      messaging.Connection[*stream.Environment]
        environment     *stream.Environment
        name            string
        streamOptions   *stream.StreamOptions
        producerOptions *stream.ProducerOptions
        mu              sync.RWMutex
}

func NewStreamsProducer(connection messaging.Connection[*stream.Environment], name string, options ...StreamsProducerOptions) *StreamsProducer <span class="cov0" title="0">{
        assert.NotNil(connection, "starting up - error setting up rabbitmq streams producer: connection is nil")
        assert.NotEmpty(name, "starting up - error setting up rabbitmq streams producer: name is empty")

        producer := &amp;StreamsProducer{
                connection:      connection,
                name:            name,
                streamOptions:   stream.NewStreamOptions(),
                producerOptions: stream.NewProducerOptions(),
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(producer)
        }</span>

        <span class="cov0" title="0">return producer</span>
}

func (streams *StreamsProducer) Produce(ctx context.Context, message *samqp.AMQP10) error <span class="cov0" title="0">{
        streams.mu.Lock()
        defer streams.mu.Unlock()

        var err error
        if streams.environment, err = streams.connection.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams producer - failed connection to stream %s: %s", streams.name, err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">var streamExists bool
        if streamExists, err = streams.environment.StreamExists(streams.name); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams producer - failed connection to stream %s: %s", streams.name, err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">if !streamExists </span><span class="cov0" title="0">{
                if err = streams.environment.DeclareStream(streams.name, streams.streamOptions); err != nil </span><span class="cov0" title="0">{
                        log.Debug(fmt.Sprintf("rabbitmq streams consumer - failed connection to stream %s: %s", streams.name, err.Error()))
                        return err
                }</span>
        }

        <span class="cov0" title="0">var producer *stream.Producer
        if producer, err = streams.environment.NewProducer(streams.name, streams.producerOptions); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams producer - failed connection to stream %s: %s", streams.name, err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq producer - publishing to stream %s", streams.name))
        if err = producer.Send(message); err != nil </span><span class="cov0" title="0">{
                log.Debug(fmt.Sprintf("rabbitmq streams producer - failed publishing message to stream %s: %s", streams.name, err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">log.Debug(fmt.Sprintf("rabbitmq producer - published to stream %s", streams.name))
        return nil</span>
}

func (streams *StreamsProducer) Close() <span class="cov0" title="0">{
        time.Sleep(messaging.Delay)

        if streams.environment != nil &amp;&amp; !streams.environment.IsClosed() </span><span class="cov0" title="0">{
                log.Debug("rabbitmq streams producer - closing connection")
                if err := streams.environment.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error(fmt.Sprintf("rabbitmq streams producer - failed to close connection to stream %s: %s", streams.name, err.Error()))
                }</span>
        }
        <span class="cov0" title="0">streams.environment = nil
        streams.connection.Close()
        log.Debug(fmt.Sprintf("rabbitmq streams consumer - producer connection to stream %s", streams.name))</span>
}

func (streams *StreamsProducer) Context() messaging.Context <span class="cov0" title="0">{
        return streams.connection.Context()
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package rabbitmq

import "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

var streamsProducerOptions = NewStreamsProducerOptions()

func NewStreamsProducerOptions() StreamsProducerOptions <span class="cov0" title="0">{
        return func(producer *StreamsProducer) </span>{<span class="cov0" title="0">
        }</span>
}

type StreamsProducerOptions func(*StreamsProducer)

func (options StreamsProducerOptions) WithProducerOptions(poptions *stream.ProducerOptions) StreamsProducerOptions <span class="cov0" title="0">{
        return func(producer *StreamsProducer) </span><span class="cov0" title="0">{
                producer.producerOptions = poptions
        }</span>
}

func (options StreamsProducerOptions) WithStreamOptions(soptions *stream.StreamOptions) StreamsProducerOptions <span class="cov0" title="0">{
        return func(producer *StreamsProducer) </span><span class="cov0" title="0">{
                producer.streamOptions = soptions
        }</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package rabbitmq

import "github.com/rabbitmq/rabbitmq-stream-go-client/pkg/stream"

type StreamsProducerOptionsChain struct {
        chain []StreamsProducerOptions
}

func StreamsProducerOptionsChainBuilder() *StreamsProducerOptionsChain <span class="cov0" title="0">{
        return &amp;StreamsProducerOptionsChain{
                chain: make([]StreamsProducerOptions, 0),
        }
}</span>

func (options *StreamsProducerOptionsChain) Build() StreamsProducerOptions <span class="cov0" title="0">{
        return func(producer *StreamsProducer) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(producer)
                }</span>
        }
}

func (options *StreamsProducerOptionsChain) WithProducerOptions(poptions *stream.ProducerOptions) *StreamsProducerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, streamsProducerOptions.WithProducerOptions(poptions))
        return options
}</span>

func (options *StreamsProducerOptionsChain) WithStreamOptions(soptions *stream.StreamOptions) *StreamsProducerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, streamsProducerOptions.WithStreamOptions(soptions))
        return options
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package security

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/rest"
)

type DefaultAuthenticationEndpoint struct {
        authenticationService AuthenticationService
}

func NewDefaultAuthenticationEndpoint(authenticationService AuthenticationService) *DefaultAuthenticationEndpoint <span class="cov0" title="0">{
        assert.NotNil(authenticationService, "starting up - error setting up authenticationEndpoint: authenticationService is nil")

        return &amp;DefaultAuthenticationEndpoint{
                authenticationService: authenticationService,
        }
}</span>

func (endpoint *DefaultAuthenticationEndpoint) Authenticate(ctx *gin.Context) <span class="cov0" title="0">{
        assert.NotNil(ctx, "authentication endpoint - error authenticating: context is nil")

        var err error
        var principal *Principal
        if err = ctx.ShouldBindJSON(&amp;principal); err != nil </span><span class="cov0" title="0">{
                ex := rest.BadRequestException("error unmarshalling request json to object")
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>

        <span class="cov0" title="0">if errs := endpoint.authenticationService.Validate(principal); errs != nil </span><span class="cov0" title="0">{
                ex := rest.BadRequestException("error validating the principal", errs...)
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>

        <span class="cov0" title="0">if err = endpoint.authenticationService.Authenticate(ctx.Request.Context(), principal); err != nil </span><span class="cov0" title="0">{
                ex := rest.UnauthorizedException(err.Error())
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, principal)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package security

import (
        "context"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/validation"
)

type DefaultAuthenticationService struct {
        passwordEncoder  PasswordEncoder
        principalManager PrincipalManager
        tokenManager     TokenManager
}

func NewDefaultAuthenticationService(passwordEncoder PasswordEncoder, principalManager PrincipalManager, tokenManager TokenManager) *DefaultAuthenticationService <span class="cov0" title="0">{
        assert.NotNil(passwordEncoder, "starting up - error setting up authenticationService: passwordEncoder is nil")
        assert.NotNil(principalManager, "starting up - error setting up authenticationService: principalManager is nil")
        assert.NotNil(tokenManager, "starting up - error setting up authenticationService: tokenManager is nil")

        return &amp;DefaultAuthenticationService{
                passwordEncoder:  passwordEncoder,
                principalManager: principalManager,
                tokenManager:     tokenManager,
        }
}</span>

func (service *DefaultAuthenticationService) Authenticate(ctx context.Context, principal *Principal) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "authentication service - error authenticating: context is nil")
        assert.NotNil(principal, "authentication service - error authenticating: principal is nil")

        var err error
        var user *Principal
        if user, err = service.principalManager.Find(ctx, *principal.Username); err != nil </span><span class="cov0" title="0">{
                return ErrAuthenticationFailed(err)
        }</span>

        <span class="cov0" title="0">var needsUpgrade *bool
        if needsUpgrade, err = service.passwordEncoder.UpgradeEncoding(*(user.Password)); err != nil || *(needsUpgrade) </span><span class="cov0" title="0">{
                return ErrAuthenticationFailed(ErrAccountExpiredPassword)
        }</span>

        <span class="cov0" title="0">var matches *bool
        if matches, err = service.passwordEncoder.Matches(*(user.Password), *principal.Password); err != nil || !*(matches) </span><span class="cov0" title="0">{
                return ErrAuthenticationFailed(ErrAccountInvalidPassword)
        }</span>

        <span class="cov0" title="0">principal.Password, principal.Passphrase = nil, nil
        principal.Role, principal.Resources = user.Role, user.Resources
        if principal.Token, err = service.tokenManager.Generate(principal); err != nil </span><span class="cov0" title="0">{
                return ErrAuthenticationFailed(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (service *DefaultAuthenticationService) Validate(principal *Principal) []error <span class="cov0" title="0">{
        assert.NotNil(principal, "authentication service - error validating: principal is nil")

        var errors []error

        if err := validation.ValidateFieldIsRequired("this", "username", principal.Username); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "role", principal.Role); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldIsRequired("this", "password", principal.Password); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "passphrase", principal.Passphrase); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "enabled", principal.Enabled); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "non_locked", principal.NonLocked); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "non_expired", principal.NonExpired); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "password_non_expired", principal.PasswordNonExpired); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "signup_done", principal.SignUpDone); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateStructMustBeUndefined("this", "resources", principal.Resources); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
                return errors
        }</span>

        <span class="cov0" title="0">if err := validation.ValidateFieldMustBeUndefined("this", "token", principal.Token); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">return errors</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package security

import (
        "context"
        "strings"

        "github.com/gin-gonic/gin"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/rest"
)

type DefaultAuthorizationFilter struct {
        authorizationService AuthorizationService
}

func NewDefaultAuthorizationFilter(authorizationService AuthorizationService) *DefaultAuthorizationFilter <span class="cov0" title="0">{
        assert.NotNil(authorizationService, "starting up - error setting up authorizationFilter: authorizationService is nil")

        return &amp;DefaultAuthorizationFilter{
                authorizationService: authorizationService,
        }
}</span>

func (filter *DefaultAuthorizationFilter) Authorize(ctx *gin.Context) <span class="cov0" title="0">{
        assert.NotNil(ctx, "authorization filter - error authorizing: context is nil")

        header := ctx.Request.Header.Get("Authorization")
        if !strings.HasPrefix(header, "Bearer ") </span><span class="cov0" title="0">{
                ex := rest.UnauthorizedException("invalid authorization header")
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>

        <span class="cov0" title="0">splits := strings.Split(header, " ")
        if len(splits) != 2 </span><span class="cov0" title="0">{
                ex := rest.UnauthorizedException("invalid authorization header")
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>
        <span class="cov0" title="0">token := splits[1]

        application, exists := GetApplicationFromContext(ctx)
        if !exists </span><span class="cov0" title="0">{
                ex := rest.NotFoundException("application name not found in context")
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>
        <span class="cov0" title="0">resource := []string{application, ctx.Request.Method, ctx.FullPath()}

        var err error
        var principal *Principal
        ctxWithResource := context.WithValue(ctx.Request.Context(), ResourceCtxKey{}, strings.Join(resource, " "))
        if principal, err = filter.authorizationService.Authorize(ctxWithResource, token); err != nil </span><span class="cov0" title="0">{
                ex := rest.UnauthorizedException(err.Error())
                ctx.AbortWithStatusJSON(ex.Code, ex)
                return
        }</span>

        <span class="cov0" title="0">AddPrincipalToContext(ctx, principal)
        ctx.Next()</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package security

import (
        "context"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type DefaultAuthorizationService struct {
        tokenManager     TokenManager
        principalManager PrincipalManager
}

func NewDefaultAuthorizationService(tokenManager TokenManager, principalManager PrincipalManager) *DefaultAuthorizationService <span class="cov0" title="0">{
        assert.NotNil(tokenManager, "starting up - error setting up authorization service: tokenManager is nil")
        assert.NotNil(principalManager, "starting up - error setting up authorization service: principalManager is nil")

        return &amp;DefaultAuthorizationService{
                tokenManager:     tokenManager,
                principalManager: principalManager,
        }
}</span>

func (service *DefaultAuthorizationService) Authorize(ctx context.Context, tokenString string) (*Principal, error) <span class="cov0" title="0">{
        assert.NotNil(ctx, "authorization service - error authorizing: context is nil")
        assert.NotEmpty(tokenString, "authorization service - error authorizing: tokenString is empty")

        var err error
        var principal *Principal
        if principal, err = service.tokenManager.Validate(tokenString); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var user *Principal
        if user, err = service.principalManager.Find(ctx, *principal.Username); err != nil </span><span class="cov0" title="0">{
                return nil, ErrAuthorizationFailed(err)
        }</span>

        <span class="cov0" title="0">if *(user.Role) != *(principal.Role) </span><span class="cov0" title="0">{
                return nil, ErrAuthorizationFailed(ErrAccountInvalidRole)
        }</span>

        <span class="cov0" title="0">var value any
        if value = ctx.Value(ResourceCtxKey{}); value == nil </span><span class="cov0" title="0">{
                return nil, ErrAuthorizationFailed(ErrAccountEmptyAuthorities)
        }</span>

        <span class="cov0" title="0">var ok bool
        var resource string
        if resource, ok = value.(string); !ok </span><span class="cov0" title="0">{
                return nil, ErrAuthorizationFailed(ErrAccountEmptyResource)
        }</span>

        <span class="cov0" title="0">if err = service.principalManager.VerifyResource(ctx, *user.Username, resource); err != nil </span><span class="cov0" title="0">{
                return nil, ErrAuthorizationFailed(err)
        }</span>

        <span class="cov0" title="0">principal.Password, principal.Passphrase, principal.Token = nil, nil, &amp;tokenString
        return principal, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package security

import (
        "errors"
        "fmt"

        secerrors "github.com/guidomantilla/go-feather-lib/pkg/common/errors"
)

var (
        ErrAccountExistingUsername    = errors.New("principal username already exists")
        ErrAccountInvalidUsername     = errors.New("principal username is invalid")
        ErrAccountEmptyRole           = errors.New("principal role is empty")
        ErrAccountInvalidRole         = errors.New("principal role is invalid")
        ErrAccountEmptyPassword       = errors.New("principal password is empty")
        ErrAccountInvalidPassword     = errors.New("principal password is invalid")
        ErrAccountEmptyPassphrase     = errors.New("principal passphrase is empty")
        ErrAccountInvalidPassphrase   = errors.New("principal passphrase is invalid")
        ErrAccountDisabled            = errors.New("principal is disabled")
        ErrAccountLocked              = errors.New("principal is locked")
        ErrAccountExpired             = errors.New("principal has expired")
        ErrAccountExpiredPassword     = errors.New("principal password has expired")
        ErrAccountEmptyAuthorities    = errors.New("principal authorities are empty")
        ErrAccountInvalidAuthorities  = errors.New("principal authorities are invalid")
        ErrAccountEmptyResource       = errors.New("principal resource is empty")
        ErrTokenFailedParsing         = errors.New("token failed to parse")
        ErrTokenInvalid               = errors.New("token is invalid")
        ErrTokenEmptyClaims           = errors.New("token claims is empty")
        ErrTokenEmptyUsernameClaim    = errors.New("token username claim is empty")
        ErrTokenInvalidUsernameClaim  = errors.New("token username claim is invalid")
        ErrTokenEmptyRoleClaim        = errors.New("token role claim is empty")
        ErrTokenInvalidRoleClaim      = errors.New("token role claim is invalid")
        ErrTokenEmptyResourcesClaim   = errors.New("token resources claim is empty")
        ErrTokenInvalidResourcesClaim = errors.New("token resources claim is invalid")
        ErrPasswordEncoderNotFound    = errors.New("password encoder not found")
        ErrPasswordLength             = errors.New("password length is too short")
        ErrPasswordSpecialChars       = errors.New("password must contain at least 2 special characters")
        ErrPasswordNumbers            = errors.New("password must contain at least 2 numbers")
        ErrPasswordUppercaseChars     = errors.New("password must contain at least 2 uppercase characters")
        ErrRawPasswordIsEmpty         = errors.New("rawPassword cannot be empty")
        ErrSaltIsNil                  = errors.New("salt cannot be nil")
        ErrSaltIsEmpty                = errors.New("salt cannot be empty")
        ErrHashFuncIsNil              = errors.New("hashFunc cannot be nil")
        ErrEncodedPasswordIsEmpty     = errors.New("encodedPassword cannot be empty")
        ErrEncodedPasswordNotAllowed  = errors.New("encodedPassword format not allowed")
        ErrBcryptCostNotAllowed       = errors.New("bcryptCost not allowed")
)

func ErrAuthenticationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("authentication failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrAuthorizationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("authorization failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrTokenGenerationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("token generation failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrTokenValidationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("token validation failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrPasswordEncodingFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("password encoding failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrPasswordMatchingFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("password matching failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrPasswordUpgradeEncodingValidationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("password upgrade encoding validation failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>

func ErrPasswordValidationFailed(errs ...error) error <span class="cov0" title="0">{
        return fmt.Errorf("password validation failed: %s", secerrors.ErrJoin(errs...).Error())
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package security

import (
        "github.com/gin-gonic/gin"
)

const (
        ApplicationCtxKey = "application"
        PrincipalCtxKey   = "principal"
)

func AddPrincipalToContext(ctx *gin.Context, principal *Principal) <span class="cov0" title="0">{
        ctx.Set(PrincipalCtxKey, principal)
}</span>

func AddApplicationToContext(ctx *gin.Context, application string) <span class="cov0" title="0">{
        ctx.Set(ApplicationCtxKey, application)
}</span>

func GetPrincipalFromContext(ctx *gin.Context) (*Principal, bool) <span class="cov0" title="0">{
        var exists bool
        var value any
        if value, exists = ctx.Get(PrincipalCtxKey); !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return value.(*Principal), true</span>
}

func GetApplicationFromContext(ctx *gin.Context) (string, bool) <span class="cov0" title="0">{
        var exists bool
        var value any
        if value, exists = ctx.Get(ApplicationCtxKey); !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">return value.(string), true</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package security

import (
        "strings"

        "golang.org/x/crypto/argon2"
)

type Argon2PasswordEncoderOption func(encoder *Argon2PasswordEncoder)

type Argon2PasswordEncoder struct {
        iterations int
        memory     int
        threads    int
        saltLength int
        keyLength  int
}

func NewArgon2PasswordEncoder(options ...Argon2PasswordEncoderOption) *Argon2PasswordEncoder <span class="cov0" title="0">{

        encoder := &amp;Argon2PasswordEncoder{
                iterations: 1,
                memory:     64 * 1024,
                threads:    2,
                saltLength: 16,
                keyLength:  32,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(encoder)
        }</span>

        <span class="cov0" title="0">return encoder</span>
}

func WithArgon2Iterations(iterations int) Argon2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Argon2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.iterations = iterations
        }</span>
}

func WithArgon2Memory(memory int) Argon2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Argon2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.memory = memory
        }</span>
}

func WithArgon2Threads(threads int) Argon2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Argon2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.threads = threads
        }</span>
}

func WithArgon2SaltLength(saltLength int) Argon2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Argon2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.saltLength = saltLength
        }</span>
}

func WithArgon2KeyLength(keyLength int) Argon2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Argon2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.keyLength = keyLength
        }</span>
}

func (encoder *Argon2PasswordEncoder) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{

        var err error
        var salt []byte
        if salt, err = GenerateSalt(encoder.saltLength); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var value *string
        if value, err = Argon2Encode(rawPassword, salt, encoder.iterations, encoder.memory, encoder.threads, encoder.keyLength); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword := *value
        encodedPassword = Argon2PrefixKey + encodedPassword
        return &amp;encodedPassword, nil</span>
}

func (encoder *Argon2PasswordEncoder) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, Argon2PrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, _, iterations, memory, threads, salt, key, err := Argon2Decode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var newEncodedPassword *string
        if newEncodedPassword, err = Argon2Encode(rawPassword, salt, *iterations, *memory, *threads, len(key)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword = strings.Replace(encodedPassword, Argon2PrefixKey, "", 1)
        matched := encodedPassword == *(newEncodedPassword)
        return &amp;matched, nil</span>
}

func (encoder *Argon2PasswordEncoder) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, Argon2PrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, version, iterations, memory, threads, salt, key, err := Argon2Decode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">upgradeNeeded := true
        if argon2.Version &gt; *(version) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.iterations &gt; *(iterations) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.memory &gt; *(memory) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.threads &gt; *(threads) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.saltLength &gt; len(salt) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.keyLength &gt; len(key) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">upgradeNeeded = false
        return &amp;upgradeNeeded, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package security

import (
        "strings"

        "golang.org/x/crypto/bcrypt"
)

type BcryptPasswordEncoderOption func(encoder *BcryptPasswordEncoder)

type BcryptPasswordEncoder struct {
        cost int
}

func NewBcryptPasswordEncoder(options ...BcryptPasswordEncoderOption) *BcryptPasswordEncoder <span class="cov0" title="0">{

        encoder := &amp;BcryptPasswordEncoder{cost: bcrypt.DefaultCost}

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(encoder)
        }</span>

        <span class="cov0" title="0">return encoder</span>
}

func WithBcryptCost(cost int) BcryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *BcryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.cost = cost
        }</span>
}

func (encoder *BcryptPasswordEncoder) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{

        if encoder.cost &lt; bcrypt.MinCost || encoder.cost &gt; bcrypt.MaxCost </span><span class="cov0" title="0">{
                return nil, ErrBcryptCostNotAllowed
        }</span>

        <span class="cov0" title="0">if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">var err error
        var bytes []byte
        if bytes, err = bcrypt.GenerateFromPassword([]byte(rawPassword), encoder.cost); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword := BcryptPrefixKey + string(bytes)
        return &amp;encodedPassword, nil</span>
}

func (encoder *BcryptPasswordEncoder) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, BcryptPrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">matched := true
        encodedPassword = strings.Replace(encodedPassword, BcryptPrefixKey, "", 1)
        if err := bcrypt.CompareHashAndPassword([]byte(encodedPassword), []byte(rawPassword)); err != nil </span><span class="cov0" title="0">{
                matched = false
        }</span>

        <span class="cov0" title="0">return &amp;matched, nil</span>
}

func (encoder *BcryptPasswordEncoder) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, BcryptPrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">encodedPassword = strings.Replace(encodedPassword, BcryptPrefixKey, "", 1)

        cost, _ := bcrypt.Cost([]byte(encodedPassword))
        upgradeNeeded := cost &lt; encoder.cost

        return &amp;upgradeNeeded, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package security

import (
        "strings"

        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

var SupportedDecoders = map[string]PasswordEncoder{
        Argon2PrefixKey: NewArgon2PasswordEncoder(),
        BcryptPrefixKey: NewBcryptPasswordEncoder(),
        Pbkdf2PrefixKey: NewPbkdf2PasswordEncoder(),
        ScryptPrefixKey: NewScryptPasswordEncoder(),
}

type DelegatingPasswordEncoderOption func(encoder *DelegatingPasswordEncoder)

type DelegatingPasswordEncoder struct {
        encoder  PasswordEncoder
        decoders map[string]PasswordEncoder
}

func NewDelegatingPasswordEncoder(encoder PasswordEncoder, options ...DelegatingPasswordEncoderOption) *DelegatingPasswordEncoder <span class="cov0" title="0">{

        if encoder == nil </span><span class="cov0" title="0">{
                log.Fatal("starting up - error setting up delegating password encoder: encoder is nil")
        }</span>

        <span class="cov0" title="0">delegator := &amp;DelegatingPasswordEncoder{
                encoder:  encoder,
                decoders: SupportedDecoders,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(delegator)
        }</span>

        <span class="cov0" title="0">return delegator</span>
}

func WithSupportedDecoders(decoders map[string]PasswordEncoder) DelegatingPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *DelegatingPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.decoders = decoders
        }</span>
}

func (delegate *DelegatingPasswordEncoder) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{
        return delegate.encoder.Encode(rawPassword)
}</span>

func (delegate *DelegatingPasswordEncoder) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        for prefix, decoder := range delegate.decoders </span><span class="cov0" title="0">{
                if strings.HasPrefix(encodedPassword, prefix) </span><span class="cov0" title="0">{
                        return decoder.Matches(encodedPassword, rawPassword)
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrPasswordEncoderNotFound</span>
}

func (delegate *DelegatingPasswordEncoder) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        for prefix, decoder := range delegate.decoders </span><span class="cov0" title="0">{
                if strings.HasPrefix(encodedPassword, prefix) </span><span class="cov0" title="0">{
                        return decoder.UpgradeEncoding(encodedPassword)
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrPasswordEncoderNotFound</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package security

import (
        "crypto/sha512"
        "hash"
        "strings"
)

type HashFunc func() hash.Hash

type Pbkdf2PasswordEncoderOption func(encoder *Pbkdf2PasswordEncoder)

type Pbkdf2PasswordEncoder struct {
        iterations int
        saltLength int
        keyLength  int
        hashFunc   HashFunc
}

func NewPbkdf2PasswordEncoder(options ...Pbkdf2PasswordEncoderOption) *Pbkdf2PasswordEncoder <span class="cov0" title="0">{

        encoder := &amp;Pbkdf2PasswordEncoder{
                iterations: 600_000,
                saltLength: 32,
                keyLength:  64,
                hashFunc:   sha512.New,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(encoder)
        }</span>

        <span class="cov0" title="0">return encoder</span>
}

func WithPbkdf2Iterations(iterations int) Pbkdf2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Pbkdf2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.iterations = iterations
        }</span>
}

func WithPbkdf2SaltLength(saltLength int) Pbkdf2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Pbkdf2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.saltLength = saltLength
        }</span>
}

func WithPbkdf2KeyLength(keyLength int) Pbkdf2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Pbkdf2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.keyLength = keyLength
        }</span>
}

func WithHashFunc(hashFunc HashFunc) Pbkdf2PasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *Pbkdf2PasswordEncoder) </span><span class="cov0" title="0">{
                encoder.hashFunc = hashFunc
        }</span>
}

func (encoder *Pbkdf2PasswordEncoder) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{

        var err error
        var salt []byte
        if salt, err = GenerateSalt(encoder.saltLength); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var value *string
        if value, err = Pbkdf2Encode(rawPassword, salt, encoder.iterations, encoder.keyLength, encoder.hashFunc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword := *value
        encodedPassword = Pbkdf2PrefixKey + encodedPassword
        return &amp;encodedPassword, nil</span>
}

func (encoder *Pbkdf2PasswordEncoder) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, Pbkdf2PrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, iterations, salt, key, err := Pbkdf2Decode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var newEncodedPassword *string
        if newEncodedPassword, err = Pbkdf2Encode(rawPassword, salt, *iterations, len(key), encoder.hashFunc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword = strings.Replace(encodedPassword, Pbkdf2PrefixKey, "", 1)
        matched := encodedPassword == *(newEncodedPassword)
        return &amp;matched, nil</span>
}

func (encoder *Pbkdf2PasswordEncoder) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, Pbkdf2PrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, iterations, salt, key, err := Pbkdf2Decode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">upgradeNeeded := true
        if encoder.iterations &gt; *(iterations) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.saltLength &gt; len(salt) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.keyLength &gt; len(key) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">upgradeNeeded = false
        return &amp;upgradeNeeded, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package security

import (
        "strings"
)

type ScryptPasswordEncoderOption func(encoder *ScryptPasswordEncoder)

type ScryptPasswordEncoder struct {
        N          int
        r          int
        p          int
        saltLength int
        keyLength  int
}

func NewScryptPasswordEncoder(options ...ScryptPasswordEncoderOption) *ScryptPasswordEncoder <span class="cov0" title="0">{

        encoder := &amp;ScryptPasswordEncoder{
                N:          32768,
                r:          8,
                p:          1,
                saltLength: 16,
                keyLength:  32,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(encoder)
        }</span>

        <span class="cov0" title="0">return encoder</span>
}

func WithScryptN(N int) ScryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *ScryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.N = N
        }</span>
}

func WithScryptR(r int) ScryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *ScryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.r = r
        }</span>
}

func WithScryptP(p int) ScryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *ScryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.p = p
        }</span>
}

func WithScryptSaltLength(saltLength int) ScryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *ScryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.saltLength = saltLength
        }</span>
}

func WithScryptKeyLength(keyLength int) ScryptPasswordEncoderOption <span class="cov0" title="0">{
        return func(encoder *ScryptPasswordEncoder) </span><span class="cov0" title="0">{
                encoder.keyLength = keyLength
        }</span>
}

func (encoder *ScryptPasswordEncoder) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{

        var err error
        var salt []byte
        if salt, err = GenerateSalt(encoder.saltLength); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var value *string
        if value, err = ScryptEncode(rawPassword, salt, encoder.N, encoder.r, encoder.p, encoder.keyLength); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword := *value
        encodedPassword = ScryptPrefixKey + encodedPassword
        return &amp;encodedPassword, nil</span>
}

func (encoder *ScryptPasswordEncoder) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, ScryptPrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, N, r, p, salt, key, err := ScryptDecode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var newEncodedPassword *string
        if newEncodedPassword, err = ScryptEncode(rawPassword, salt, *N, *r, *p, len(key)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">encodedPassword = strings.Replace(encodedPassword, ScryptPrefixKey, "", 1)
        matched := encodedPassword == *(newEncodedPassword)
        return &amp;matched, nil</span>
}

func (encoder *ScryptPasswordEncoder) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(encodedPassword, ScryptPrefixKey) </span><span class="cov0" title="0">{
                return nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">_, N, r, p, salt, key, err := ScryptDecode(encodedPassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">upgradeNeeded := true
        if encoder.N &gt; *(N) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.r &gt; *(r) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.p &gt; *(p) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.saltLength &gt; len(salt) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">if encoder.keyLength &gt; len(key) </span><span class="cov0" title="0">{
                return &amp;upgradeNeeded, nil
        }</span>

        <span class="cov0" title="0">upgradeNeeded = false
        return &amp;upgradeNeeded, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package security

import (
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "io"
        "strings"

        "golang.org/x/crypto/argon2"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/crypto/scrypt"
)

func GenerateSalt(saltSize int) ([]byte, error) <span class="cov0" title="0">{

        var err error
        unEncodedSalt := make([]byte, saltSize)
        if _, err = io.ReadFull(rand.Reader, unEncodedSalt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">length := base64.StdEncoding.EncodedLen(len(unEncodedSalt))
        encodedSalt := make([]byte, length)
        base64.StdEncoding.Encode(encodedSalt, unEncodedSalt)

        return encodedSalt, nil</span>
}

func Pbkdf2Encode(rawPassword string, salt []byte, iterations int, keyLength int, fn HashFunc) (*string, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if salt == nil </span><span class="cov0" title="0">{
                return nil, ErrSaltIsNil
        }</span>

        <span class="cov0" title="0">if len(salt) == 0 </span><span class="cov0" title="0">{
                return nil, ErrSaltIsEmpty
        }</span>

        <span class="cov0" title="0">if fn == nil </span><span class="cov0" title="0">{
                return nil, ErrHashFuncIsNil
        }</span>

        <span class="cov0" title="0">bytes := pbkdf2.Key([]byte(rawPassword), salt, iterations, keyLength, fn)

        b64Salt := base64.RawStdEncoding.EncodeToString(salt)
        b64Key := base64.RawStdEncoding.EncodeToString(bytes)

        encodedPassword := fmt.Sprintf("$%d$%s$%s", iterations, b64Salt, b64Key)
        return &amp;encodedPassword, nil</span>
}

func Pbkdf2Decode(encodedPassword string) (*string, *int, []byte, []byte, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">values := strings.Split(encodedPassword, "$")
        if len(values) != 4 </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var err error
        var prefix string
        if _, err = fmt.Sscanf(values[0], "%s", &amp;prefix); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var iterations int
        if _, err = fmt.Sscanf(values[1], "%d", &amp;iterations); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var salt []byte
        salt, err = base64.RawStdEncoding.Strict().DecodeString(values[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var key []byte
        key, err = base64.RawStdEncoding.Strict().DecodeString(values[3])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">return &amp;prefix, &amp;iterations, salt, key, nil</span>

}

func ScryptEncode(rawPassword string, salt []byte, N int, r int, p int, keyLen int) (*string, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if salt == nil </span><span class="cov0" title="0">{
                return nil, ErrSaltIsNil
        }</span>

        <span class="cov0" title="0">if len(salt) == 0 </span><span class="cov0" title="0">{
                return nil, ErrSaltIsEmpty
        }</span>

        <span class="cov0" title="0">var err error
        var bytes []byte
        if bytes, err = scrypt.Key([]byte(rawPassword), salt, N, r, p, keyLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">b64Salt := base64.RawStdEncoding.EncodeToString(salt)
        b64Key := base64.RawStdEncoding.EncodeToString(bytes)

        encodedPassword := fmt.Sprintf("$%d$%d$%d$%s$%s", N, r, p, b64Salt, b64Key)
        return &amp;encodedPassword, nil</span>
}

func ScryptDecode(encodedPassword string) (*string, *int, *int, *int, []byte, []byte, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">values := strings.Split(encodedPassword, "$")
        if len(values) != 6 </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var err error
        var prefix string
        if _, err = fmt.Sscanf(values[0], "%s", &amp;prefix); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var N int
        if _, err = fmt.Sscanf(values[1], "%d", &amp;N); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var r int
        if _, err = fmt.Sscanf(values[2], "%d", &amp;r); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var p int
        if _, err = fmt.Sscanf(values[3], "%d", &amp;p); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var salt []byte
        salt, err = base64.RawStdEncoding.Strict().DecodeString(values[4])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var key []byte
        key, err = base64.RawStdEncoding.Strict().DecodeString(values[5])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">return &amp;prefix, &amp;N, &amp;r, &amp;p, salt, key, nil</span>

}

func Argon2Encode(rawPassword string, salt []byte, iterations int, memory int, threads int, keyLen int) (*string, error) <span class="cov0" title="0">{

        if rawPassword == "" </span><span class="cov0" title="0">{
                return nil, ErrRawPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">if salt == nil </span><span class="cov0" title="0">{
                return nil, ErrSaltIsNil
        }</span>

        <span class="cov0" title="0">if len(salt) == 0 </span><span class="cov0" title="0">{
                return nil, ErrSaltIsEmpty
        }</span>

        <span class="cov0" title="0">key := argon2.IDKey([]byte(rawPassword), salt, uint32(iterations), uint32(memory), uint8(threads), uint32(keyLen))

        b64Salt := base64.RawStdEncoding.EncodeToString(salt)
        b64Key := base64.RawStdEncoding.EncodeToString(key)

        encodedPassword := fmt.Sprintf("$%d$%d$%d$%d$%s$%s", argon2.Version, iterations, memory, threads, b64Salt, b64Key)
        return &amp;encodedPassword, nil</span>
}

func Argon2Decode(encodedPassword string) (*string, *int, *int, *int, *int, []byte, []byte, error) <span class="cov0" title="0">{

        if encodedPassword == "" </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordIsEmpty
        }</span>

        <span class="cov0" title="0">values := strings.Split(encodedPassword, "$")
        if len(values) != 7 </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var err error
        var prefix string
        if _, err = fmt.Sscanf(values[0], "%s", &amp;prefix); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var version int
        if _, err = fmt.Sscanf(values[1], "%d", &amp;version); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var iterations int
        if _, err = fmt.Sscanf(values[2], "%d", &amp;iterations); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var memory int
        if _, err = fmt.Sscanf(values[3], "%d", &amp;memory); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var threads int
        if _, err = fmt.Sscanf(values[4], "%d", &amp;threads); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var salt []byte
        salt, err = base64.RawStdEncoding.Strict().DecodeString(values[5])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">var key []byte
        key, err = base64.RawStdEncoding.Strict().DecodeString(values[6])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, nil, nil, nil, ErrEncodedPasswordNotAllowed
        }</span>

        <span class="cov0" title="0">return &amp;prefix, &amp;version, &amp;iterations, &amp;memory, &amp;threads, salt, key, nil</span>

}
</pre>
		
		<pre class="file" id="file71" style="display: none">package security

import (
        "crypto/rand"
        "math/big"
        math "math/rand"
        "strings"

        "github.com/guidomantilla/go-feather-lib/pkg/common/utils"
)

const (
        lowerCharSet   = "abcdedfghijklmnopqrst"
        upperCharSet   = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        specialCharSet = "@#$%^&amp;*-_!+=[]{}|\\:',.?/`~\"();&lt;&gt;"
        numberSet      = "0123456789"
        allCharSet     = lowerCharSet + upperCharSet + specialCharSet + numberSet
        //allCharSet = lowerCharSet + upperCharSet + numberSet
)

type passwordGenerator struct {
        passwordLength int
        minSpecialChar int
        minNum         int
        minUpperCase   int
}

func NewPasswordGenerator(options ...PasswordGeneratorOptions) PasswordGenerator <span class="cov0" title="0">{

        generator := &amp;passwordGenerator{
                passwordLength: 16,
                minSpecialChar: 2,
                minNum:         2,
                minUpperCase:   2,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(generator)
        }</span>

        <span class="cov0" title="0">return generator</span>
}

func (generator *passwordGenerator) Generate() string <span class="cov0" title="0">{
        var password strings.Builder

        //Set special character
        for i := 0; i &lt; generator.minSpecialChar; i++ </span><span class="cov0" title="0">{
                random, _ := rand.Int(rand.Reader, big.NewInt(int64(len(specialCharSet))))
                password.WriteString(string(specialCharSet[random.Int64()]))
        }</span>

        //Set numeric
        <span class="cov0" title="0">for i := 0; i &lt; generator.minNum; i++ </span><span class="cov0" title="0">{
                random, _ := rand.Int(rand.Reader, big.NewInt(int64(len(numberSet))))
                password.WriteString(string(numberSet[random.Int64()]))
        }</span>

        //Set uppercase
        <span class="cov0" title="0">for i := 0; i &lt; generator.minUpperCase; i++ </span><span class="cov0" title="0">{
                random, _ := rand.Int(rand.Reader, big.NewInt(int64(len(upperCharSet))))
                password.WriteString(string(upperCharSet[random.Int64()]))
        }</span>

        <span class="cov0" title="0">remainingLength := generator.passwordLength - generator.minSpecialChar - generator.minNum - generator.minUpperCase
        for i := 0; i &lt; remainingLength; i++ </span><span class="cov0" title="0">{
                random, _ := rand.Int(rand.Reader, big.NewInt(int64(len(allCharSet))))
                password.WriteString(string(allCharSet[random.Int64()]))
        }</span>
        <span class="cov0" title="0">inRune := []rune(password.String())
        math.Shuffle(len(inRune), func(i, j int) </span><span class="cov0" title="0">{
                inRune[i], inRune[j] = inRune[j], inRune[i]
        }</span>)
        <span class="cov0" title="0">return string(inRune)</span>
}

func (generator *passwordGenerator) Validate(rawPassword string) error <span class="cov0" title="0">{

        if len(rawPassword) &lt; generator.passwordLength </span><span class="cov0" title="0">{
                return ErrPasswordLength
        }</span>

        <span class="cov0" title="0">minSpecialCharCont := 0
        minNumCont := 0
        minUpperCaseCont := 0

        for _, c := range rawPassword </span><span class="cov0" title="0">{
                switch </span>{
                case strings.ContainsRune(specialCharSet, c):<span class="cov0" title="0">
                        minSpecialCharCont++</span>
                case strings.ContainsRune(numberSet, c):<span class="cov0" title="0">
                        minNumCont++</span>
                case strings.ContainsRune(upperCharSet, c):<span class="cov0" title="0">
                        minUpperCaseCont++</span>
                }
        }

        <span class="cov0" title="0">if minSpecialCharCont &lt; generator.minSpecialChar </span><span class="cov0" title="0">{
                return ErrPasswordSpecialChars
        }</span>

        <span class="cov0" title="0">if minNumCont &lt; generator.minNum </span><span class="cov0" title="0">{
                return ErrPasswordNumbers
        }</span>

        <span class="cov0" title="0">if minUpperCaseCont &lt; generator.minUpperCase </span><span class="cov0" title="0">{
                return ErrPasswordUppercaseChars
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (generator *passwordGenerator) set(property string, value int) <span class="cov0" title="0">{
        if utils.IsEmpty(property) || utils.IsEmpty(value) || value &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch property </span>{
        case "passwordLength":<span class="cov0" title="0">
                if value &gt;= 16 </span><span class="cov0" title="0">{
                        generator.passwordLength = value
                }</span>
        case "minSpecialChar":<span class="cov0" title="0">
                if value &gt;= 2 </span><span class="cov0" title="0">{
                        generator.minSpecialChar = value
                }</span>
        case "minNum":<span class="cov0" title="0">
                if value &gt;= 2 </span><span class="cov0" title="0">{
                        generator.minNum = value
                }</span>
        case "minUpperCase":<span class="cov0" title="0">
                if value &gt;= 2 </span><span class="cov0" title="0">{
                        generator.minUpperCase = value
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package security

var passwordGeneratorOptions = NewPasswordGeneratorOptions()

func NewPasswordGeneratorOptions() PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span>{<span class="cov0" title="0">
        }</span>
}

type PasswordGeneratorOptions func(generator PasswordGenerator)

func (options PasswordGeneratorOptions) WithPasswordLength(passwordLength int) PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span><span class="cov0" title="0">{
                generator.set("passwordLength", passwordLength)
        }</span>
}

func (options PasswordGeneratorOptions) WithMinSpecialChar(minSpecialChar int) PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span><span class="cov0" title="0">{
                generator.set("minSpecialChar", minSpecialChar)
        }</span>
}

func (options PasswordGeneratorOptions) WithMinNum(minNum int) PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span><span class="cov0" title="0">{
                generator.set("minNum", minNum)
        }</span>
}

func (options PasswordGeneratorOptions) WithMinUpperCase(minUpperCase int) PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span><span class="cov0" title="0">{
                generator.set("minUpperCase", minUpperCase)
        }</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package security

type PasswordGeneratorOptionsChain struct {
        chain []PasswordGeneratorOptions
}

func PasswordGeneratorOptionsChainBuilder() *PasswordGeneratorOptionsChain <span class="cov0" title="0">{
        return &amp;PasswordGeneratorOptionsChain{
                chain: make([]PasswordGeneratorOptions, 0),
        }
}</span>

func (options *PasswordGeneratorOptionsChain) Build() PasswordGeneratorOptions <span class="cov0" title="0">{
        return func(generator PasswordGenerator) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(generator)
                }</span>
        }
}

func (options *PasswordGeneratorOptionsChain) WithPasswordLength(length int) *PasswordGeneratorOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, passwordGeneratorOptions.WithPasswordLength(length))
        return options
}</span>

func (options *PasswordGeneratorOptionsChain) WithMinSpecialChar(minSpecialChar int) *PasswordGeneratorOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, passwordGeneratorOptions.WithMinSpecialChar(minSpecialChar))
        return options
}</span>

func (options *PasswordGeneratorOptionsChain) WithMinNum(minNum int) *PasswordGeneratorOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, passwordGeneratorOptions.WithMinNum(minNum))
        return options
}</span>

func (options *PasswordGeneratorOptionsChain) WithMinUpperCase(minUpperCase int) *PasswordGeneratorOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, passwordGeneratorOptions.WithMinUpperCase(minUpperCase))
        return options
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package security

import (
        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type passwordManager struct {
        passwordEncoder   PasswordEncoder
        passwordGenerator PasswordGenerator
}

func NewPasswordManager(passwordEncoder PasswordEncoder, passwordGenerator PasswordGenerator) PasswordManager <span class="cov0" title="0">{
        assert.NotNil(passwordEncoder, "starting up - error setting up passwordManager: passwordEncoder is nil")
        assert.NotNil(passwordGenerator, "starting up - error setting up passwordManager: passwordGenerator is nil")

        return &amp;passwordManager{
                passwordEncoder:   passwordEncoder,
                passwordGenerator: passwordGenerator,
        }
}</span>

func (manager *passwordManager) Encode(rawPassword string) (*string, error) <span class="cov0" title="0">{

        var err error
        var password *string
        if password, err = manager.passwordEncoder.Encode(rawPassword); err != nil </span><span class="cov0" title="0">{
                return nil, ErrPasswordEncodingFailed(err)
        }</span>

        <span class="cov0" title="0">return password, nil</span>
}

func (manager *passwordManager) Matches(encodedPassword string, rawPassword string) (*bool, error) <span class="cov0" title="0">{

        var err error
        var ok *bool
        if ok, err = manager.passwordEncoder.Matches(encodedPassword, rawPassword); err != nil </span><span class="cov0" title="0">{
                return nil, ErrPasswordMatchingFailed(err)
        }</span>

        <span class="cov0" title="0">return ok, nil</span>
}

func (manager *passwordManager) UpgradeEncoding(encodedPassword string) (*bool, error) <span class="cov0" title="0">{

        var err error
        var ok *bool
        if ok, err = manager.passwordEncoder.UpgradeEncoding(encodedPassword); err != nil </span><span class="cov0" title="0">{
                return nil, ErrPasswordUpgradeEncodingValidationFailed(err)
        }</span>

        <span class="cov0" title="0">return ok, nil</span>
}

func (manager *passwordManager) Generate() string <span class="cov0" title="0">{
        return manager.passwordGenerator.Generate()
}</span>

func (manager *passwordManager) Validate(rawPassword string) error <span class="cov0" title="0">{

        var err error
        if err = manager.passwordGenerator.Validate(rawPassword); err != nil </span><span class="cov0" title="0">{
                return ErrPasswordValidationFailed(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (manager *passwordManager) set(property string, value int) <span class="cov0" title="0">{
        manager.passwordGenerator.set(property, value)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package security

import (
        "context"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
)

type BasePrincipalManager struct {
        principalRepo   map[string]*Principal
        resourceRepo    map[string]map[string]string
        passwordManager PasswordManager
}

func NewBasePrincipalManager(passwordManager PasswordManager) *BasePrincipalManager <span class="cov0" title="0">{
        assert.NotNil(passwordManager, "starting up - error setting up principalManager: passwordManager is nil")

        return &amp;BasePrincipalManager{
                passwordManager: passwordManager,
                principalRepo:   make(map[string]*Principal),
                resourceRepo:    make(map[string]map[string]string),
        }
}</span>

func (manager *BasePrincipalManager) Create(ctx context.Context, principal *Principal) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error creating: context is nil")
        assert.NotNil(principal, "principal manager - error creating: principal is nil")

        var err error
        if err = manager.Exists(ctx, *principal.Username); err == nil </span><span class="cov0" title="0">{
                return ErrAccountExistingUsername
        }</span>

        <span class="cov0" title="0">if err = manager.passwordManager.Validate(*principal.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if principal.Password, err = manager.passwordManager.Encode(*principal.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">manager.principalRepo[*principal.Username] = principal
        manager.resourceRepo[*principal.Username] = make(map[string]string)

        for _, resource := range principal.Resources </span><span class="cov0" title="0">{
                manager.resourceRepo[*principal.Username][resource] = resource
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (manager *BasePrincipalManager) Update(ctx context.Context, principal *Principal) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error updating: context is nil")
        assert.NotNil(principal, "principal manager - error updating: principal is nil")

        return manager.Create(ctx, principal)
}</span>

func (manager *BasePrincipalManager) Delete(ctx context.Context, username string) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error deleting: context is nil")
        assert.NotEmpty(username, "principal manager - error deleting: username is empty")

        delete(manager.principalRepo, username)
        delete(manager.resourceRepo, username)
        return nil
}</span>

func (manager *BasePrincipalManager) Find(ctx context.Context, username string) (*Principal, error) <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error finding: context is nil")
        assert.NotEmpty(username, "principal manager - error finding: username is empty")

        var ok bool
        var user *Principal
        if user, ok = manager.principalRepo[username]; !ok </span><span class="cov0" title="0">{
                return nil, ErrAccountInvalidUsername
        }</span>

        <span class="cov0" title="0">if user.Role == nil || *(user.Role) == "" </span><span class="cov0" title="0">{
                return nil, ErrAccountEmptyRole
        }</span>

        <span class="cov0" title="0">if user.Password == nil || *(user.Password) == "" </span><span class="cov0" title="0">{
                return nil, ErrAccountEmptyPassword
        }</span>

        <span class="cov0" title="0">if user.Enabled != nil &amp;&amp; !*(user.Enabled) </span><span class="cov0" title="0">{
                return nil, ErrAccountDisabled
        }</span>

        <span class="cov0" title="0">if user.NonLocked != nil &amp;&amp; !*(user.NonLocked) </span><span class="cov0" title="0">{
                return nil, ErrAccountLocked
        }</span>

        <span class="cov0" title="0">if user.NonExpired != nil &amp;&amp; !*(user.NonExpired) </span><span class="cov0" title="0">{
                return nil, ErrAccountExpired
        }</span>

        <span class="cov0" title="0">if user.PasswordNonExpired != nil &amp;&amp; !*(user.PasswordNonExpired) </span><span class="cov0" title="0">{
                return nil, ErrAccountExpiredPassword
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (manager *BasePrincipalManager) Exists(ctx context.Context, username string) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error exists: context is nil")
        assert.NotEmpty(username, "principal manager - error exists: username is empty")

        var ok bool
        if _, ok = manager.principalRepo[username]; !ok </span><span class="cov0" title="0">{
                return ErrAccountInvalidUsername
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (manager *BasePrincipalManager) ChangePassword(ctx context.Context, username string, password string) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error changing password: context is nil")
        assert.NotEmpty(username, "principal manager - error changing password: username is empty")
        assert.NotEmpty(password, "principal manager - error changing password: password is empty")

        var err error
        if err = manager.Exists(ctx, username); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = manager.passwordManager.Validate(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user := manager.principalRepo[username]
        if user.Password, err = manager.passwordManager.Encode(password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (manager *BasePrincipalManager) VerifyResource(ctx context.Context, username string, resource string) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "principal manager - error verifying resource: context is nil")
        assert.NotEmpty(username, "principal manager - error verifying resource: username is empty")
        assert.NotEmpty(resource, "principal manager - error verifying resource: resource is empty")

        var err error
        if err = manager.Exists(ctx, username); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, ok := manager.resourceRepo[username][resource]; !ok </span><span class="cov0" title="0">{
                return ErrAccountInvalidAuthorities
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package security

import (
        "context"
        "errors"
        "strings"

        "github.com/xorcare/pointer"
        "gorm.io/gorm"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/config"
        "github.com/guidomantilla/go-feather-lib/pkg/datasource"
)

type GormPrincipalManager struct {
        transactionHandler datasource.TransactionHandler[*gorm.DB]
        passwordManager    PasswordManager
}

func NewGormPrincipalManager(transactionHandler datasource.TransactionHandler[*gorm.DB], passwordManager PasswordManager) *GormPrincipalManager <span class="cov0" title="0">{
        assert.NotNil(transactionHandler, "starting up - error setting up principalManager: transactionHandler is nil")
        assert.NotNil(passwordManager, "starting up - error setting up principalManager: passwordManager is nil")

        return &amp;GormPrincipalManager{
                transactionHandler: transactionHandler,
                passwordManager:    passwordManager,
        }
}</span>

func (manager *GormPrincipalManager) Create(_ context.Context, _ *Principal) error <span class="cov0" title="0">{
        panic("not implemented. no required for this coding challenge")</span>
}

func (manager *GormPrincipalManager) Update(_ context.Context, _ *Principal) error <span class="cov0" title="0">{
        panic("not implemented. no required for this coding challenge")</span>
}

func (manager *GormPrincipalManager) Delete(_ context.Context, _ string) error <span class="cov0" title="0">{
        panic("not implemented. no required for this coding challenge")</span>
}

func (manager *GormPrincipalManager) Find(ctx context.Context, username string) (*Principal, error) <span class="cov0" title="0">{

        var user *Principal
        err := manager.transactionHandler.HandleTransaction(ctx, func(ctx context.Context, tx *gorm.DB) error </span><span class="cov0" title="0">{

                var principals []AuthPrincipal
                if err := tx.Find(&amp;principals, "username = ? AND application = ?", username, config.Application).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(principals) == 0 </span><span class="cov0" title="0">{
                        return errors.New("principal does not exists")
                }</span>

                <span class="cov0" title="0">principal := principals[0]
                if principal.Role == nil || *(principal.Role) == "" </span><span class="cov0" title="0">{
                        return ErrAccountEmptyRole
                }</span>

                <span class="cov0" title="0">if principal.Password == nil || *(principal.Password) == "" </span><span class="cov0" title="0">{
                        return ErrAccountEmptyPassword
                }</span>

                <span class="cov0" title="0">if principal.Enabled != nil &amp;&amp; !*(principal.Enabled) </span><span class="cov0" title="0">{
                        return ErrAccountDisabled
                }</span>

                <span class="cov0" title="0">resources := make([]string, 0)
                for _, principal := range principals </span><span class="cov0" title="0">{
                        resources = append(resources, strings.Join([]string{*principal.Application, *principal.Permission, *principal.Resource}, " "))
                }</span>

                <span class="cov0" title="0">user = &amp;Principal{
                        Username:           principal.Username,
                        Role:               principal.Role,
                        Password:           principal.Password,
                        Passphrase:         principal.Passphrase,
                        Enabled:            principal.Enabled,
                        NonLocked:          pointer.Bool(true),
                        NonExpired:         pointer.Bool(true),
                        PasswordNonExpired: pointer.Bool(true),
                        SignUpDone:         pointer.Bool(true),
                        Resources:          resources,
                }

                return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (manager *GormPrincipalManager) Exists(_ context.Context, _ string) error <span class="cov0" title="0">{
        panic("not implemented. no required for this coding challenge")</span>
}

func (manager *GormPrincipalManager) ChangePassword(_ context.Context, _ string, _ string) error <span class="cov0" title="0">{
        panic("not implemented. no required for this coding challenge")</span>
}

func (manager *GormPrincipalManager) VerifyResource(ctx context.Context, username string, resource string) error <span class="cov0" title="0">{

        return manager.transactionHandler.HandleTransaction(ctx, func(ctx context.Context, tx *gorm.DB) error </span><span class="cov0" title="0">{

                var principals []AuthPrincipal
                if err := tx.Find(&amp;principals, "username = ? AND CONCAT(application, ' ', permission, ' ', resource) = ?", username, resource).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(principals) == 0 </span><span class="cov0" title="0">{
                        return errors.New("principal resource undefined")
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package security

import (
        "encoding/json"
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
        "github.com/xorcare/pointer"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/utils"
)

type Claims struct {
        jwt.RegisteredClaims
        Principal
}

type JwtTokenManager struct {
        issuer        string
        timeout       time.Duration
        signingKey    any
        verifyingKey  any
        signingMethod jwt.SigningMethod
}

func NewJwtTokenManager(options ...JwtTokenManagerOptions) *JwtTokenManager <span class="cov0" title="0">{

        tokenManager := &amp;JwtTokenManager{
                issuer:        "",
                timeout:       time.Hour * 24,
                signingKey:    "some_long_signing_key",
                verifyingKey:  "some_long_verifying_key",
                signingMethod: jwt.SigningMethodHS512,
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(tokenManager)
        }</span>

        <span class="cov0" title="0">return tokenManager</span>
}

func (manager *JwtTokenManager) Generate(principal *Principal) (*string, error) <span class="cov0" title="0">{
        assert.NotNil(principal, "token manager - error generating token: principal is nil")

        claims := &amp;Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    manager.issuer,
                        Subject:   *principal.Username,
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(manager.timeout)),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
                Principal: *principal,
        }

        token := jwt.NewWithClaims(manager.signingMethod, claims)

        var err error
        var tokenString string
        if tokenString, err = token.SignedString(manager.signingKey); err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenGenerationFailed(err)
        }</span>

        <span class="cov0" title="0">return &amp;tokenString, nil</span>
}

func (manager *JwtTokenManager) Validate(tokenString string) (*Principal, error) <span class="cov0" title="0">{
        assert.NotEmpty(tokenString, "token manager - error validating token: token is empty")

        getKeyFunc := func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                return manager.verifyingKey, nil
        }</span>

        <span class="cov0" title="0">parserOptions := []jwt.ParserOption{
                jwt.WithIssuer(manager.issuer),
                jwt.WithValidMethods([]string{manager.signingMethod.Alg()}),
        }

        var err error
        var token *jwt.Token
        if token, err = jwt.Parse(tokenString, getKeyFunc, parserOptions...); err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenFailedParsing, err)
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenInvalid)
        }</span>

        <span class="cov0" title="0">var ok bool
        var mapClaims jwt.MapClaims
        if mapClaims, ok = token.Claims.(jwt.MapClaims); !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyClaims)
        }</span>

        <span class="cov0" title="0">var value any
        if value, ok = mapClaims["username"]; !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyUsernameClaim)
        }</span>

        <span class="cov0" title="0">var username string
        if username, ok = value.(string); !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyUsernameClaim)
        }</span>

        <span class="cov0" title="0">if value, ok = mapClaims["role"]; !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyRoleClaim)
        }</span>

        <span class="cov0" title="0">var role string
        if role, ok = value.(string); !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyRoleClaim)
        }</span>

        <span class="cov0" title="0">if value, ok = mapClaims["resources"]; !ok </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenEmptyResourcesClaim)
        }</span>

        <span class="cov0" title="0">var resourcesBytes []byte
        if resourcesBytes, err = json.Marshal(value); err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenInvalidResourcesClaim)
        }</span>

        <span class="cov0" title="0">var resources []string
        if err = json.Unmarshal(resourcesBytes, &amp;resources); err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenValidationFailed(ErrTokenInvalidResourcesClaim)
        }</span>

        <span class="cov0" title="0">principal := &amp;Principal{
                Username:  pointer.Of(username),
                Role:      pointer.Of(role),
                Resources: resources,
        }

        return principal, nil</span>
}

func (manager *JwtTokenManager) set(property string, value any) <span class="cov0" title="0">{
        if utils.IsEmpty(property) || utils.IsEmpty(value) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch property </span>{
        case "issuer":<span class="cov0" title="0">
                manager.issuer = utils.ToString(value)</span>
        case "timeout":<span class="cov0" title="0">
                if value.(time.Duration) &gt; 0 </span><span class="cov0" title="0">{
                        manager.timeout = value.(time.Duration)
                }</span>
        case "signingMethod":<span class="cov0" title="0">
                if value.(jwt.SigningMethod) != nil </span><span class="cov0" title="0">{
                        manager.signingMethod = value.(jwt.SigningMethod)
                }</span>
        case "signingKey":<span class="cov0" title="0">
                if value != nil </span><span class="cov0" title="0">{
                        manager.signingKey = value
                }</span>
        case "verifyingKey":<span class="cov0" title="0">
                if value != nil </span><span class="cov0" title="0">{
                        manager.verifyingKey = value
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package security

import (
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
)

var jwtTokenManagerOptions = NewJwtTokenManagerOptions()

func NewJwtTokenManagerOptions() JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span>{<span class="cov0" title="0">
        }</span>
}

type JwtTokenManagerOptions func(tokenManager TokenManager)

func (options JwtTokenManagerOptions) WithIssuer(issuer string) JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                tokenManager.set("issuer", issuer)
        }</span>
}

func (options JwtTokenManagerOptions) WithTimeout(timeout time.Duration) JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                tokenManager.set("timeout", timeout)
        }</span>
}

func (options JwtTokenManagerOptions) WithSigningMethod(signingMethod jwt.SigningMethod) JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                tokenManager.set("signingMethod", signingMethod)
        }</span>
}

func (options JwtTokenManagerOptions) WithSigningKey(signingKey any) JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                tokenManager.set("signingKey", signingKey)
        }</span>
}

func (options JwtTokenManagerOptions) WithVerifyingKey(verifyingKey any) JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                tokenManager.set("verifyingKey", verifyingKey)
        }</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package security

import (
        "time"

        jwt "github.com/golang-jwt/jwt/v5"
)

type JwtTokenManagerOptionsChain struct {
        chain []JwtTokenManagerOptions
}

func JwtTokenManagerOptionsChainBuilder() *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        return &amp;JwtTokenManagerOptionsChain{
                chain: make([]JwtTokenManagerOptions, 0),
        }
}</span>

func (options *JwtTokenManagerOptionsChain) Build() JwtTokenManagerOptions <span class="cov0" title="0">{
        return func(tokenManager TokenManager) </span><span class="cov0" title="0">{
                for _, option := range options.chain </span><span class="cov0" title="0">{
                        option(tokenManager)
                }</span>
        }
}

func (options *JwtTokenManagerOptionsChain) WithIssuer(issuer string) *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, jwtTokenManagerOptions.WithIssuer(issuer))
        return options
}</span>

func (options *JwtTokenManagerOptionsChain) WithTimeout(timeout time.Duration) *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, jwtTokenManagerOptions.WithTimeout(timeout))
        return options
}</span>

func (options *JwtTokenManagerOptionsChain) WithSigningMethod(signingMethod jwt.SigningMethod) *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, jwtTokenManagerOptions.WithSigningMethod(signingMethod))
        return options
}</span>

func (options *JwtTokenManagerOptionsChain) WithSigningKey(signingKey any) *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, jwtTokenManagerOptions.WithSigningKey(signingKey))
        return options
}</span>

func (options *JwtTokenManagerOptionsChain) WithVerifyingKey(verifyingKey any) *JwtTokenManagerOptionsChain <span class="cov0" title="0">{
        options.chain = append(options.chain, jwtTokenManagerOptions.WithVerifyingKey(verifyingKey))
        return options
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package server

import (
        "net/http"

        cron "github.com/robfig/cron/v3"
        "google.golang.org/grpc"

        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

func BuildBaseServer() (string, Server) <span class="cov0" title="0">{
        return "base-server", NewBaseServer()
}</span>

func BuildCronServer(cron *cron.Cron) (string, Server) <span class="cov0" title="0">{
        return "cron-server", NewCronServer(cron)
}</span>

func BuildHttpServer(server *http.Server) (string, Server) <span class="cov0" title="0">{
        return "http-server", NewHttpServer(server)
}</span>

func BuildGrpcServer(address string, server *grpc.Server) (string, Server) <span class="cov0" title="0">{
        return "grpc-server", NewGrpcServer(address, server)
}</span>

func BuildRabbitMQServer(consumers ...messaging.Consumer) (string, Server) <span class="cov0" title="0">{
        return "rabbitmq-server", NewRabbitMQServer(consumers...)
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package server

import (
        "context"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type BaseServer struct {
        ctx          context.Context
        closeChannel chan struct{}
}

func NewBaseServer() *BaseServer <span class="cov0" title="0">{
        return &amp;BaseServer{
                closeChannel: make(chan struct{}),
        }
}</span>

func (server *BaseServer) Run(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "base server - error starting up: context is nil")

        server.ctx = ctx
        log.Info("starting up - starting base server")
        &lt;-server.closeChannel
        return nil
}</span>

func (server *BaseServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "base server - error shutting down: context is nil")

        log.Info("shutting down - stopping base server")
        close(server.closeChannel)
        log.Debug("shutting down - default base stopped")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package server

import (
        "context"

        cron "github.com/robfig/cron/v3"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type CronServer struct {
        ctx          context.Context
        internal     *cron.Cron
        closeChannel chan struct{}
}

func NewCronServer(cron *cron.Cron) *CronServer <span class="cov0" title="0">{
        assert.NotNil(cron, "starting up - error setting up cron server: cron is nil")

        return &amp;CronServer{
                internal:     cron,
                closeChannel: make(chan struct{}),
        }
}</span>

func (server *CronServer) Run(ctx context.Context) error <span class="cov0" title="0">{

        server.ctx = ctx
        log.Info("starting up - starting cron server")
        server.internal.Start()
        &lt;-server.closeChannel
        return nil
}</span>

func (server *CronServer) Stop(_ context.Context) error <span class="cov0" title="0">{

        log.Info("shutting down - stopping cron server")
        close(server.closeChannel)
        server.internal.Stop()
        log.Debug("shutting down - cron server stopped")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "net"
        "net/http"

        "google.golang.org/grpc"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type GrpcServer struct {
        ctx      context.Context
        address  string
        internal *grpc.Server
}

func NewGrpcServer(address string, server *grpc.Server) *GrpcServer <span class="cov0" title="0">{
        assert.NotEmpty(address, "starting up - error setting up grpc server: address is empty")
        assert.NotNil(server, "starting up - error setting up grpc server: server is nil")

        return &amp;GrpcServer{
                address:  address,
                internal: server,
        }
}</span>

func (server *GrpcServer) Run(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "grpc server - error starting up: context is nil")

        server.ctx = ctx
        log.Info(fmt.Sprintf("starting up - starting grpc server: %s", server.address))

        var err error
        var listener net.Listener
        if listener, err = net.Listen("tcp", server.address); err != nil </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("starting up - starting grpc server error: %s", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">if err = server.internal.Serve(listener); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("starting up - starting grpc server error: %s", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (server *GrpcServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "grpc server - error shutting down: context is nil")

        log.Info("shutting down - stopping grpc server")
        server.internal.GracefulStop()
        log.Debug("shutting down - grpc server stopped")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
)

type HttpServer struct {
        ctx      context.Context
        internal *http.Server
}

func NewHttpServer(server *http.Server) *HttpServer <span class="cov0" title="0">{
        assert.NotNil(server, "starting up - error setting up http server: server is nil")

        return &amp;HttpServer{
                internal: server,
        }
}</span>

func (server *HttpServer) Run(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "http server - error starting: context is nil")

        server.ctx = ctx
        log.Info(fmt.Sprintf("starting up - starting http server: %s", server.internal.Addr))

        if err := server.internal.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("starting up - starting http server error: %s", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (server *HttpServer) Stop(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "http server - error shutting down: context is nil")

        log.Info("shutting down - stopping http server")
        if err := server.internal.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error(fmt.Sprintf("shutting down - forced shutdown: %s", err.Error()))
                return err
        }</span>
        <span class="cov0" title="0">log.Debug("shutting down - http server stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package server

import (
        "context"
        "fmt"

        "github.com/guidomantilla/go-feather-lib/pkg/common/assert"
        "github.com/guidomantilla/go-feather-lib/pkg/common/log"
        "github.com/guidomantilla/go-feather-lib/pkg/messaging"
)

type RabbitMQServer struct {
        ctx          context.Context
        consumers    []messaging.Consumer
        closeChannel chan struct{}
}

func NewRabbitMQServer(consumers ...messaging.Consumer) *RabbitMQServer <span class="cov0" title="0">{
        assert.NotEmpty(consumers, "starting up - error setting up rabbitmq server: consumers is empty")

        return &amp;RabbitMQServer{
                consumers:    consumers,
                closeChannel: make(chan struct{}),
        }
}</span>

func (server *RabbitMQServer) Run(ctx context.Context) error <span class="cov0" title="0">{
        assert.NotNil(ctx, "rabbitmq server - error starting up: context is nil")

        server.ctx = ctx
        log.Info(fmt.Sprintf("starting up - starting rabbitmq server: %s", server.consumers[0].Context().Server()))

        for _, consumer := range server.consumers </span><span class="cov0" title="0">{
                go func(ctx context.Context, consumer messaging.Consumer, closeChannel chan struct{}) </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-closeChannel:<span class="cov0" title="0">
                                        return</span>

                                default:<span class="cov0" title="0">
                                        var err error
                                        var closeChannel chan string
                                        if closeChannel, err = consumer.Consume(ctx); err != nil </span><span class="cov0" title="0">{
                                                log.Error(fmt.Sprintf("rabbitmq server - error: %s", err.Error()))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">&lt;-closeChannel</span>
                                }
                        }
                }(ctx, consumer, server.closeChannel)
        }
        <span class="cov0" title="0">&lt;-server.closeChannel
        return nil</span>
}

func (server *RabbitMQServer) Stop(_ context.Context) error <span class="cov0" title="0">{
        assert.NotNil(server.ctx, "rabbitmq server - error shutting down: context is nil")

        log.Debug("server shutting down - stopping rabbitmq server")
        close(server.closeChannel)
        for _, consumer := range server.consumers </span><span class="cov0" title="0">{
                consumer.Close()
        }</span>
        <span class="cov0" title="0">log.Debug("server shutting down - rabbitmq server stopped")
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
